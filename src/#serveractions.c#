#include <pthread.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/time.h>
#include <math.h>
#include "shipinfo.h"
#include "parse.h"
#include "hashtable.h"
#include "msgqueue.h"
#include "universe.h"
#include "serveractions.h"
#include "common.h"
#include "portinfo.h"
#include "boxmuller.h"
#include "config.h"
#include "planet.h"
#include "types.h"
#include "globals.h"
#include <jansson.h>

extern struct sector **sectors;
extern struct list *symbols[HASH_LENGTH];
extern struct player **players;
extern struct sp_shipinfo **shiptypes;
extern planetClass **planetTypes;
extern struct ship **ships;
extern struct port **ports;
extern struct planet **planets;
extern struct config *configdata;
extern struct node **nodes;
extern struct sector **sectors;
extern struct list *symbols[HASH_LENGTH];
extern struct player **players;
extern struct ship **ships;
extern struct port **ports;
extern struct planet **planets;
extern struct config *configdata;
extern int sectorcount;
extern int WARP_WAIT;
extern struct timeval begin, end;

/* Function prototypes to satisfy compiler */
void buy (struct player *curplayer, struct port *curport,
	  struct ship *curship, char *buffer);
void sell (struct player *curplayer, struct port *curport,
	   struct ship *curship, char *buffer);
//void buyhardware (char *buffer, struct player *curplayer);

// Forward declarations for functions not shown in the snippets but used here
// void builddescription (int sector, char *buffer, int playernum);

json_t *builddescription_json(int sector, int playernum);
void buildnewplayer (struct player *curplayer, char *shipname);
json_t *move_player(json_t *request_json);
json_t *buildplayerinfo_json (struct player *curplayer);
json_t *buildshipinfo_json (struct ship *curship);
//void trading (struct player *curplayer, struct port *curport, struct ship *curship, json_t *json_data, char *buffer);
void trading (struct player *curplayer, struct port *curport, char *buffer,
	      struct ship *curship);
json_t *buildportinfo_json (struct port *curport);
json_t *totalplanetinfo_json (struct planet *curplanet);
//void buildtotalinfo (int pnumb, char *buffer, json_t * json_data);
json_t * buildtotalinfo (int pnumb);
void listships (char *buffer);
void buyship (char *buffer, struct player *curplayer);
void sell (struct player *curplayer, struct port *curport,
	   struct ship *curship, char *buffer);
void buy (struct player *curplayer, struct port *curport,
	  struct ship *curship, char *buffer);



void send_json_response (int sockid, json_t *response)
{
  // Placeholder. This function would serialize the JSON and send it over the socket.
  json_decref(response); // Clean up the JSON object.
}


/* void */
/* processcommand (json_t *json_data, char *response_buffer, size_t buffer_size) */
/* { */
/*   // A local JSON object to build the response */
/*   json_t *response_json = json_object (); */
/*   int command_int; */
/*   int subcmd_int; */
/*   const char *name = NULL; */
/*   json_t *temp_json; */
/*   json_t *subcommand_json; */
/*   //const char *json_string; */
/*   const char *json_data_string = json_dumps (response_json, JSON_COMPACT); */

/*   // Get the command type from the JSON data */
/*   temp_json = json_object_get (json_data, "cmd"); */
/*   if (!json_is_integer (temp_json)) */
/*     { */
/*       // Handle error: command is missing or not an integer */
/*       json_object_set_new (response_json, "status", json_string ("ERROR")); */
/*       json_object_set_new (response_json, "message", */
/* 			   json_string ("Command missing or invalid.")); */
/*       json_data_string = json_dumps (response_json, JSON_COMPACT); */
/*       strncpy (response_buffer, json_data_string, buffer_size); */
/*       response_buffer[buffer_size - 1] = '\0'; */
/*       free ((void *) json_data_string); */
/*       json_decref (response_json); */
/*       return; */
/*     } */
/*   command_int = (int) json_integer_value (temp_json); */

/*   // Get the player name from the JSON data */
/*   temp_json = json_object_get (json_data, "name"); */
/*   if (json_is_string (temp_json)) */
/*     { */
/*       name = json_string_value (temp_json); */
/*     } */

/*   // Handle various commands */
/*   switch (command_int) */
/*     { */
/*     case ct_login: */
/*       { */
/* 	struct player *curplayer = NULL; */
/* 	json_t *player_name_json = json_object_get (json_data, "playername"); */
/* 	if (json_is_string (player_name_json)) */
/* 	  { */
/* 	    const char *player_name = json_string_value (player_name_json); */
/* 	    curplayer = */
/* 	      (struct player *) find (player_name, player, symbols, */
/* 				      HASH_LENGTH); */
/* 	    if (curplayer) */
/* 	      { */
/* 		json_t *player_info = buildplayerinfo_json (curplayer); */
/* 		json_object_set_new (response_json, "status", */
/* 				     json_string ("OK")); */
/* 		json_object_set_new (response_json, "player_info", */
/* 				     player_info); */
/* 	      } */
/* 	    else */
/* 	      { */
/* 		json_object_set_new (response_json, "status", */
/* 				     json_string ("ERROR")); */
/* 		json_object_set_new (response_json, "message", */
/* 				     json_string ("Player not found.")); */
/* 	      } */
/* 	  } */
/* 	else */
/* 	  { */
/* 	    json_object_set_new (response_json, "status", */
/* 				 json_string ("ERROR")); */
/* 	    json_object_set_new (response_json, "message", */
/* 				 json_string ("Player name missing.")); */
/* 	  } */
/* 	break; */
/*       } */

/*     case ct_newplayer: */
/*       { */
/* 	struct player *newplayer; */
/* 	json_t *player_name_json = json_object_get (json_data, "playername"); */
/* 	json_t *ship_name_json = json_object_get (json_data, "shipname"); */
/* 	if (json_is_string (player_name_json) */
/* 	    && json_is_string (ship_name_json)) */
/* 	  { */
/* 	    const char *player_name = json_string_value (player_name_json); */
/* 	    const char *ship_name = json_string_value (ship_name_json); */
/* 	    newplayer = */
/* 	      (struct player *) insert (player_name, player, symbols, */
/* 					HASH_LENGTH); */
/* 	    if (newplayer != NULL) */
/* 	      { */
/* 		buildnewplayer (newplayer, (char *) ship_name); */
/* 		json_object_set_new (response_json, "status", */
/* 				     json_string ("OK")); */
/* 		json_object_set_new (response_json, "message", */
/* 				     json_string ("New player created.")); */
/* 	      } */
/* 	    else */
/* 	      { */
/* 		json_object_set_new (response_json, "status", */
/* 				     json_string ("ERROR")); */
/* 		json_object_set_new (response_json, "message", */
/* 				     json_string ("Player creation failed.")); */
/* 	      } */
/* 	else */
/* 	  { */
/* 	    json_object_set_new (response_json, "status", */
/* 				 json_string ("ERROR")); */
/* 	    json_object_set_new (response_json, "message", */
/* 				 json_string */
/* 				 ("Invalid parameters for newplayer.")); */
/* 	  } */
/* 	break; */
/*       } */
/*     } */
/*     case ct_move: */
/*       { */
/* 	// The new move_player function handles finding the player itself. */
/* 	// It takes the json_data and returns a response object. */
/* 	json_t *response_json = move_player(json_data); */

/* 	// Now, you can use the response_json object. */
/* 	// Assuming you have a function to send the response back to the client. */
/* 	send_json_response(client_socket, response_json); */
    
/* 	// Remember to decrease the reference count when you're done with the object */
/* 	json_decref(response_json); */
/*       } */
/*       break; */
/*     } */
/*     case ct_describe: */
/*       { */
/* 	struct player *curplayer = */
/* 	  (struct player *) find (name, player, symbols, HASH_LENGTH); */
/* 	if (curplayer) */
/* 	  { */
/* 	    builddescription (curplayer->sector, response_buffer, */
/* 			      curplayer->number); */
/* 	  } */
/* 	else */
/* 	  { */
/* 	    json_object_set_new (response_json, "status", */
/* 				 json_string ("ERROR")); */
/* 	    json_object_set_new (response_json, "message", */
/* 				 json_string ("Player not found.")); */
/* 	  } */
/* 	break; */
/*       } */

/*     case ct_port: */
/*       { */
/* 	struct player *curplayer = */
/* 	  (struct player *) find (name, player, symbols, HASH_LENGTH); */
/* 	if (!curplayer) */
/* 	  { */
/* 	    json_object_set_new (response_json, "status", */
/* 				 json_string ("ERROR")); */
/* 	    json_object_set_new (response_json, "message", */
/* 				 json_string ("Player not found.")); */
/* 	    break; */
/* 	  } */

/* 	struct port *curport = sectors[curplayer->sector - 1]->portptr; */
/* 	if (!curport) */
/* 	  { */
/* 	    json_object_set_new (response_json, "status", */
/* 				 json_string ("ERROR")); */
/* 	    json_object_set_new (response_json, "message", */
/* 				 json_string ("You are not in a port!")); */
/* 	    break; */
/* 	  } */

/* 	subcommand_json = json_object_get (json_data, "subcmd"); */
/* 	if (!json_is_integer (subcommand_json)) */
/* 	  { */
/* 	    json_object_set_new (response_json, "status", */
/* 				 json_string ("ERROR")); */
/* 	    json_object_set_new (response_json, "message", */
/* 				 json_string */
/* 				 ("Subcommand missing or invalid.")); */
/* 	    break; */
/* 	  } */
/* 	subcmd_int = (int) json_integer_value (subcommand_json); */

/* 	switch (subcmd_int) */
/* 	  { */
/* 	  case ct_leave: */
/* 	    ships[curplayer->ship - 1]->flags = */
/* 	      ships[curplayer->ship - 1]->flags & (S_MAX ^ S_PORTED); */
/* 	    json_object_set_new (response_json, "status", json_string ("OK")); */
/* 	    json_object_set_new (response_json, "message", */
/* 				 json_string ("You have left the port!")); */
/* 	    break; */
/* 	  case ct_buy: */
/* 	    trading (curplayer, curport, response_buffer, */
/* 		     ships[curplayer->ship - 1]); */
/* 	    // trading(curplayer, curport, ships[curplayer->ship - 1], json_data, response_buffer); */
/* 	    // trading() populates the buffer directly */
/* 	    break; */
/* 	  case ct_sell: */
/* 	    trading (curplayer, curport, response_buffer, */
/* 		     ships[curplayer->ship - 1]); */
/* 	    break; */
/* 	  case ct_list_hardware: */
/* 	    json_t *hardware_json = list_hardware(NULL, curplayer); */
/* 	    json_decref(hardware_json); // or use the returned object as needed	     */
/* 	    break; */
/* 	  case ct_buy_hardware: */
/* 	    buyhardware (response_buffer, curplayer); */
/* 	    break; */
/* 	  default: */
/* 	    json_object_set_new (response_json, "status", */
/* 				 json_string ("ERROR")); */
/* 	    json_object_set_new (response_json, "message", */
/* 				 json_string ("Unknown subcommand.")); */
/* 	    break; */
/* 	  } */
/* 	break; */
/*       } */

/*     case ct_shipinfo: */
/*       { */
/* 	struct player *curplayer = */
/* 	  (struct player *) find (name, player, symbols, HASH_LENGTH); */
/* 	if (curplayer && curplayer->ship > 0) */
/* 	  { */
/* 	    json_t *ship_info = */
/* 	      buildshipinfo_json (ships[curplayer->ship - 1]); */
/* 	    json_object_set_new (response_json, "status", json_string ("OK")); */
/* 	    json_object_set_new (response_json, "ship_info", ship_info); */
/* 	  } */
/* 	else */
/* 	  { */
/* 	    json_object_set_new (response_json, "status", */
/* 				 json_string ("ERROR")); */
/* 	    json_object_set_new (response_json, "message", */
/* 				 json_string */
/* 				 ("Ship not found or player has no ship.")); */
/* 	  } */
/* 	break; */
/*       } */

/*     case ct_portinfo: */
/*       { */
/* 	struct player *curplayer = */
/* 	  (struct player *) find (name, player, symbols, HASH_LENGTH); */
/* 	if (curplayer && curplayer->sector > 0 */
/* 	    && sectors[curplayer->sector - 1]->portptr != NULL) */
/* 	  { */
/* 	    json_t *port_info = */
/* 	      buildportinfo_json (sectors[curplayer->sector - 1]->portptr); */
/* 	    json_object_set_new (response_json, "status", json_string ("OK")); */
/* 	    json_object_set_new (response_json, "port_info", port_info); */
/* 	  } */
/* 	else */
/* 	  { */
/* 	    json_object_set_new (response_json, "status", */
/* 				 json_string ("ERROR")); */
/* 	    json_object_set_new (response_json, "message", */
/* 				 json_string */
/* 				 ("No port in your current sector.")); */
/* 	  } */
/* 	break; */
/*       } */

/*     case ct_planet: */
/*       { */
/* 	struct player *curplayer = */
/* 	  (struct player *) find (name, player, symbols, HASH_LENGTH); */
/* 	if (curplayer && curplayer->sector > 0 */
/* 	    && sectors[curplayer->sector - 1]->planets != NULL) */
/* 	  { */
/* 	    // Assume there's only one planet in the sector for simplicity */
/* 	    struct list *planets_list = */
/* 	      sectors[curplayer->sector - 1]->planets; */
/* 	    if (planets_list) */
/* 	      { */
/* 		json_t *planet_info = */
/* 		  totalplanetinfo_json ((struct planet *) planets_list->item); */
/* 		json_object_set_new (response_json, "status", */
/* 				     json_string ("OK")); */
/* 		json_object_set_new (response_json, "planet_info", */
/* 				     planet_info); */
/* 	      } */
/* 	    else */
/* 	      { */
/* 		json_object_set_new (response_json, "status", */
/* 				     json_string ("ERROR")); */
/* 		json_object_set_new (response_json, "message", */
/* 				     json_string */
/* 				     ("No planet in this sector.")); */
/* 	      } */
/* 	  } */
/* 	else */
/* 	  { */
/* 	    json_object_set_new (response_json, "status", */
/* 				 json_string ("ERROR")); */
/* 	    json_object_set_new (response_json, "message", */
/* 				 json_string */
/* 				 ("Player not found or not in a sector with a planet.")); */
/* 	  } */
/* 	break; */
/*       } */

/*       // Additional cases would be added here */
/*     case ct_whosonline: */
/*       whosonline (response_buffer); */
/*       break; */

/*     case ct_listships: */
/*       listships (response_buffer); */
/*       break; */

/*     case ct_buyship: */
/*       { */
/* 	struct player *curplayer = */
/* 	  (struct player *) find (name, player, symbols, HASH_LENGTH); */
/* 	if (curplayer) */
/* 	  { */
/* 	    buyship (response_buffer, curplayer); */
/* 	  } */
/* 	else */
/* 	  { */
/* 	    json_object_set_new (response_json, "status", */
/* 				 json_string ("ERROR")); */
/* 	    json_object_set_new (response_json, "message", */
/* 				 json_string ("Player not found.")); */
/* 	  } */
/*       } */
/*       break; */

/*     case ct_sellship: */
/*       { */
/* 	struct player *curplayer = */
/* 	  (struct player *) find (name, player, symbols, HASH_LENGTH); */
/* 	if (curplayer) */
/* 	  { */
/* 	    sellship (response_buffer, curplayer); */
/* 	  } */
/* 	else */
/* 	  { */
/* 	    json_object_set_new (response_json, "status", */
/* 				 json_string ("ERROR")); */
/* 	    json_object_set_new (response_json, "message", */
/* 				 json_string ("Player not found.")); */
/* 	  } */
/*       } */
/*       break; */

/*     default: */
/*       json_object_set_new (response_json, "status", json_string ("ERROR")); */
/*       json_object_set_new (response_json, "message", */
/* 			   json_string ("Unknown command.")); */
/*       break; */
/*     } */
/* } */
/*   // If the buffer was not already populated by a function call, serialize the response */
/*   if (response_buffer[0] == '\0' && json_object_size (response_json) > 0) */
/*     { */
/*       json_data_string = json_dumps (response_json, JSON_COMPACT); */
/*       if (json_data_string) */
/* 	{ */
/* 	  strncpy (response_buffer, json_data_string, buffer_size); */
/* 	  response_buffer[buffer_size - 1] = '\0'; */
/* 	  free ((void *) json_data_string); */
/* 	} */
/*     } */

/*   json_decref (response_json); */
/* } */


// Corrected processcommand function
void
processcommand (int client_socket, json_t *json_data, char *response_buffer, size_t buffer_size)
{
  // A local JSON object to build the response
  json_t *response_json = json_object ();
  int command_int;
  int subcmd_int;
  const char *name = NULL;
  json_t *temp_json;
  json_t *subcommand_json;
  const char *json_data_string = json_dumps (response_json, JSON_COMPACT);

  // Get the command type from the JSON data
  temp_json = json_object_get (json_data, "cmd");
  if (!json_is_integer (temp_json))
    {
      // Handle error
      json_object_set_new (response_json, "status", json_string ("ERROR"));
      json_object_set_new (response_json, "message",
			   json_string ("Command missing or invalid."));
      json_data_string = json_dumps (response_json, JSON_COMPACT);
      strncpy (response_buffer, json_data_string, buffer_size);
      response_buffer[buffer_size - 1] = '\0';
      free ((void *) json_data_string);
      json_decref (response_json);
      return;
    }
  command_int = (int) json_integer_value (temp_json);

  // Get the player name from the JSON data
  temp_json = json_object_get (json_data, "name");
  if (json_is_string (temp_json))
    {
      name = json_string_value (temp_json);
    }

  // Handle various commands
  switch (command_int)
    {
    case ct_login:
      {
	struct player *curplayer = NULL;
	json_t *player_name_json = json_object_get (json_data, "playername");
	if (json_is_string (player_name_json))
	  {
	    const char *player_name = json_string_value (player_name_json);
	    curplayer =
	      (struct player *) find (player_name, player, symbols,
				      HASH_LENGTH);
	    if (curplayer)
	      {
		json_t *player_info = buildplayerinfo_json (curplayer);
		json_object_set_new (response_json, "status",
				     json_string ("OK"));
		json_object_set_new (response_json, "player_info",
				     player_info);
	      }
	    else
	      {
		json_object_set_new (response_json, "status",
				     json_string ("ERROR"));
		json_object_set_new (response_json, "message",
				     json_string ("Player not found."));
	      }
	  }
	else
	  {
	    json_object_set_new (response_json, "status",
				 json_string ("ERROR"));
	    json_object_set_new (response_json, "message",
				 json_string ("Player name missing."));
	  }
	break;
      }

    case ct_newplayer:
      {
	struct player *newplayer;
	json_t *player_name_json = json_object_get (json_data, "playername");
	json_t *ship_name_json = json_object_get (json_data, "shipname");
	if (json_is_string (player_name_json)
	    && json_is_string (ship_name_json))
	  {
	    const char *player_name = json_string_value (player_name_json);
	    const char *ship_name = json_string_value (ship_name_json);
	    newplayer =
	      (struct player *) insert (player_name, player, symbols,
					HASH_LENGTH);
	    if (newplayer != NULL)
	      {
		buildnewplayer (newplayer, (char *) ship_name);
		json_object_set_new (response_json, "status",
				     json_string ("OK"));
		json_object_set_new (response_json, "message",
				     json_string ("New player created."));
	      }
	    else
	      {
		json_object_set_new (response_json, "status",
				     json_string ("ERROR"));
		json_object_set_new (response_json, "message",
				     json_string ("Player creation failed."));
	      }
	  }
	else
	  {
	    json_object_set_new (response_json, "status",
				 json_string ("ERROR"));
	    json_object_set_new (response_json, "message",
				 json_string
				 ("Invalid parameters for newplayer."));
	  }
	break;
      }

    case ct_move:
      {
	json_t *response_json = move_player(json_data);
	send_json_response(client_socket, response_json);
	json_decref(response_json);
      }
      break;
    
    case ct_describe:
      {
	struct player *curplayer =
	  (struct player *) find (name, player, symbols, HASH_LENGTH);
	if (curplayer)
	  {
	    builddescription (curplayer->sector, response_buffer,
			      curplayer->number);
	  }
	else
	  {
	    json_object_set_new (response_json, "status",
				 json_string ("ERROR"));
	    json_object_set_new (response_json, "message",
				 json_string ("Player not found."));
	  }
	break;
      }

    case ct_port:
      {
	struct player *curplayer =
	  (struct player *) find (name, player, symbols, HASH_LENGTH);
	if (!curplayer)
	  {
	    json_object_set_new (response_json, "status",
				 json_string ("ERROR"));
	    json_object_set_new (response_json, "message",
				 json_string ("Player not found."));
	    break;
	  }

	struct port *curport = sectors[curplayer->sector - 1]->portptr;
	if (!curport)
	  {
	    json_object_set_new (response_json, "status",
				 json_string ("ERROR"));
	    json_object_set_new (response_json, "message",
				 json_string ("You are not in a port!"));
	    break;
	  }

	subcommand_json = json_object_get (json_data, "subcmd");
	if (!json_is_integer (subcommand_json))
	  {
	    json_object_set_new (response_json, "status",
				 json_string ("ERROR"));
	    json_object_set_new (response_json, "message",
				 json_string
				 ("Subcommand missing or invalid."));
	    break;
	  }
	subcmd_int = (int) json_integer_value (subcommand_json);

	switch (subcmd_int)
	  {
	  case ct_leave:
	    ships[curplayer->ship - 1]->flags =
	      ships[curplayer->ship - 1]->flags & (S_MAX ^ S_PORTED);
	    json_object_set_new (response_json, "status", json_string ("OK"));
	    json_object_set_new (response_json, "message",
				 json_string ("You have left the port!"));
	    break;
	  case ct_buy:
	    trading (curplayer, curport, response_buffer,
		     ships[curplayer->ship - 1]);
	    break;
	  case ct_sell:
	    trading (curplayer, curport, response_buffer,
		     ships[curplayer->ship - 1]);
	    break;
	  case ct_list_hardware:
	    json_t *hardware_json = list_hardware(NULL, curplayer);
	    json_decref(hardware_json);
	    break;
	  case ct_buy_hardware:
	    buyhardware (response_buffer, curplayer);
	    break;
	  default:
	    json_object_set_new (response_json, "status",
				 json_string ("ERROR"));
	    json_object_set_new (response_json, "message",
				 json_string ("Unknown subcommand."));
	    break;
	  }
	break;
      }

    case ct_shipinfo:
      {
	struct player *curplayer =
	  (struct player *) find (name, player, symbols, HASH_LENGTH);
	if (curplayer && curplayer->ship > 0)
	  {
	    json_t *ship_info =
	      buildshipinfo_json (ships[curplayer->ship - 1]);
	    json_object_set_new (response_json, "status", json_string ("OK"));
	    json_object_set_new (response_json, "ship_info", ship_info);
	  }
	else
	  {
	    json_object_set_new (response_json, "status",
				 json_string ("ERROR"));
	    json_object_set_new (response_json, "message",
				 json_string
				 ("Ship not found or player has no ship."));
	  }
	break;
      }

    case ct_portinfo:
      {
	struct player *curplayer =
	  (struct player *) find (name, player, symbols, HASH_LENGTH);
	if (curplayer && curplayer->sector > 0
	    && sectors[curplayer->sector - 1]->portptr != NULL)
	  {
	    json_t *port_info =
	      buildportinfo_json (sectors[curplayer->sector - 1]->portptr);
	    json_object_set_new (response_json, "status", json_string ("OK"));
	    json_object_set_new (response_json, "port_info", port_info);
	  }
	else
	  {
	    json_object_set_new (response_json, "status",
				 json_string ("ERROR"));
	    json_object_set_new (response_json, "message",
				 json_string
				 ("No port in your current sector."));
	  }
	break;
      }

    case ct_planet:
      {
	struct player *curplayer =
	  (struct player *) find (name, player, symbols, HASH_LENGTH);
	if (curplayer && curplayer->sector > 0
	    && sectors[curplayer->sector - 1]->planets != NULL)
	  {
	    struct list *planets_list =
	      sectors[curplayer->sector - 1]->planets;
	    if (planets_list)
	      {
		json_t *planet_info =
		  totalplanetinfo_json ((struct planet *) planets_list->item);
		json_object_set_new (response_json, "status",
				     json_string ("OK"));
		json_object_set_new (response_json, "planet_info",
				     planet_info);
	      }
	    else
	      {
		json_object_set_new (response_json, "status",
				     json_string ("ERROR"));
		json_object_set_new (response_json, "message",
				     json_string
				     ("No planet in this sector."));
	      }
	  }
	else
	  {
	    json_object_set_new (response_json, "status",
				 json_string ("ERROR"));
	    json_object_set_new (response_json, "message",
				 json_string
				 ("Player not found or not in a sector with a planet."));
	  }
	break;
      }

    case ct_whosonline:
      whosonline (response_buffer);
      break;

    case ct_listships:
      listships (response_buffer);
      break;

    case ct_buyship:
      {
	struct player *curplayer =
	  (struct player *) find (name, player, symbols, HASH_LENGTH);
	if (curplayer)
	  {
	    buyship (response_buffer, curplayer);
	  }
	else
	  {
	    json_object_set_new (response_json, "status",
				 json_string ("ERROR"));
	    json_object_set_new (response_json, "message",
				 json_string ("Player not found."));
	  }
      }
      break;

    case ct_sellship:
      {
	struct player *curplayer =
	  (struct player *) find (name, player, symbols, HASH_LENGTH);
	if (curplayer)
	  {
	    sellship (response_buffer, curplayer);
	  }
	else
	  {
	    json_object_set_new (response_json, "status",
				 json_string ("ERROR"));
	    json_object_set_new (response_json, "message",
				 json_string ("Player not found."));
	  }
      }
      break;

    default:
      json_object_set_new (response_json, "status", json_string ("ERROR"));
      json_object_set_new (response_json, "message",
			   json_string ("Unknown command."));
      break;
    }

  if (response_buffer[0] == '\0' && json_object_size (response_json) > 0)
    {
      json_data_string = json_dumps (response_json, JSON_COMPACT);
      if (json_data_string)
	{
	  strncpy (response_buffer, json_data_string, buffer_size);
	  response_buffer[buffer_size - 1] = '\0';
	  free ((void *) json_data_string);
	}
    }

  json_decref (response_json);
}


///////////////////////////////////////////////////
///////////////////////////////////////////////////
///////////////////////////////////////////////////
///////////////////////////////////////////////////
///////////////////////////////////////////////////
///////////////////////////////////////////////////


/* JSON-native replacement for builddescription */
json_t *builddescription(int sector, int playernum)
{
    json_t *root = json_object();

    /* Sector number */
    json_object_set_new(root, "sector", json_integer(sector));

    /* Warp links */
    json_t *warps = json_array();
    int linknum = 1;
    while (linknum < MAX_WARPS_PER_SECTOR &&
           sectors[sector - 1]->sectorptr[linknum] != NULL) {
        json_array_append_new(warps,
            json_integer(sectors[sector - 1]->sectorptr[linknum++ - 1]->number));
    }
    /* Add the last warp as in original */
    if (sectors[sector - 1]->sectorptr[linknum - 1] != NULL) {
        json_array_append_new(warps,
            json_integer(sectors[sector - 1]->sectorptr[linknum - 1]->number));
    }
    json_object_set_new(root, "warps", warps);

    /* Beacon text */
    json_object_set_new(root, "beacon", 
        json_string(sectors[sector - 1]->beacontext));

    /* Nebulae */
    if (strlen(sectors[sector - 1]->nebulae) <= 1)
        json_object_set_new(root, "nebulae", json_string(""));
    else
        json_object_set_new(root, "nebulae",
            json_string(sectors[sector - 1]->nebulae));

    /* Port */
    if (sectors[sector - 1]->portptr != NULL &&
        sectors[sector - 1]->portptr->invisible == 0) {
        json_t *port = json_object();
        json_object_set_new(port, "name",
            json_string(sectors[sector - 1]->portptr->name));
        json_object_set_new(port, "type",
            json_integer(sectors[sector - 1]->portptr->type));
        json_object_set_new(root, "port", port);
    } else {
        json_object_set_new(root, "port", json_null());
    }

    /* Players in sector (excluding current) */
    json_t *players = json_array();
    struct list *element = sectors[sector - 1]->playerlist[0];
    while (element != NULL) {
        struct player *pl = (struct player *)element->item;
        if (pl->number != playernum) {
            json_array_append_new(players, json_integer(pl->number));
        }
        element = element->listptr;
    }
    json_object_set_new(root, "players", players);

    /* Fighters (original code left blank placeholders) */
    json_object_set_new(root, "fighters", json_integer(0));
    json_object_set_new(root, "fighter_mode", json_string(""));

    /* Planets */
    json_t *planets = json_array();
    element = sectors[sector - 1]->planets;
    while (element != NULL) {
        struct planet *pl = (struct planet *)element->item;
        json_t *planet = json_object();
        json_object_set_new(planet, "num", json_integer(pl->num));
        json_object_set_new(planet, "name", json_string(pl->name));
        json_object_set_new(planet, "class", json_string(pl->pClass->typeClass));
        json_array_append_new(planets, planet);
        element = element->listptr;
    }
    json_object_set_new(root, "planets", planets);

    return root;
}


/* //This wants the sector number, not array posistion */
/* void */
/* builddescription (int sector, char *buffer, int playernum) */
/* { */
/*   int linknum = 1; */
/*   struct list *element; */
/*   int p = 0; */
/*   enum planettype curtype; */
/*   char ptype[5] = "\0"; */
/*   char pname[BUFF_SIZE]; */

/*   buffer[0] = '\0'; */
/*   strcpy (pname, "\0"); */
/*   addint (buffer, sector, ':', BUFF_SIZE); */

/*   //This is safe b/c no sector has no warps */
/*   while (linknum < MAX_WARPS_PER_SECTOR */
/* 	 && sectors[sector - 1]->sectorptr[linknum] != NULL) */
/*     addint (buffer, sectors[sector - 1]->sectorptr[linknum++ - 1]->number, */
/* 	    ',', BUFF_SIZE); */
/*   addint (buffer, sectors[sector - 1]->sectorptr[linknum - 1]->number, ':', */
/* 	  BUFF_SIZE); */

/*   addstring (buffer, sectors[sector - 1]->beacontext, ':', BUFF_SIZE); */
/*   if (strlen (sectors[sector - 1]->nebulae) == 0 */
/*       || strlen (sectors[sector - 1]->nebulae) == 1) */
/*     addstring (buffer, "", ':', BUFF_SIZE); */
/*   else */
/*     addstring (buffer, sectors[sector - 1]->nebulae, ':', BUFF_SIZE); */
/*   if (sectors[sector - 1]->portptr != NULL) */
/*     { */
/*       if (sectors[sector - 1]->portptr->invisible == 0) */
/* 	{ */
/* 	  addstring (buffer, sectors[sector - 1]->portptr->name, ':', */
/* 		     BUFF_SIZE); */
/* 	  addint (buffer, sectors[sector - 1]->portptr->type, ':', BUFF_SIZE); */
/* 	} */
/*       else */
/* 	{ */
/* 	  addstring (buffer, "", ':', BUFF_SIZE); */
/* 	  addstring (buffer, "", ':', BUFF_SIZE); */
/* 	} */
/*     } */
/*   else */
/*     { */
/*       addstring (buffer, "", ':', BUFF_SIZE); */
/*       addstring (buffer, "", ':', BUFF_SIZE); */
/*     } */
/*   element = sectors[sector - 1]->playerlist[0]; */
/*   if (element == NULL) */
/*     addstring (buffer, "", ':', BUFF_SIZE); */
/*   else */
/*     { */
/*       do */
/* 	{ */
/* 	  if (((struct player *) element->item)->number != playernum) */
/* 	    { */
/* 	      if (p != 0) */
/* 		addint (buffer, p, ',', BUFF_SIZE); */
/* 	      p = ((struct player *) element->item)->number; */
/* 	    } */
/* 	  element = element->listptr; */
/* 	} */
/*       while (element != NULL); */
/*       if (p != 0) */
/* 	addint (buffer, p, ':', BUFF_SIZE); */
/*       else */
/* 	addstring (buffer, "", ':', BUFF_SIZE); */
/*     } */
/*   addstring (buffer, "", ':', BUFF_SIZE);	/\* # of fighters goes here *\/ */
/*   addstring (buffer, "", ':', BUFF_SIZE);	/\* Mode of fighters goes here *\/ */
/*   /\* Now comes planets! *\/ */
/*   p = 0; */
/*   element = NULL; */
/*   element = sectors[sector - 1]->planets; */
/*   if (element == NULL) */
/*     addstring (buffer, "", ':', BUFF_SIZE); */
/*   else */
/*     { */
/*       do */
/* 	{ */
/* 	  if (p != 0) */
/* 	    { */
/* 	      addint (buffer, p, ',', BUFF_SIZE); */
/* 	      addstring (buffer, pname, ',', BUFF_SIZE); */
/* 	      addstring (buffer, ptype, ',', BUFF_SIZE); */
/* 	    } */
/* 	  p = ((struct planet *) element->item)->num; */
/* 	  strcpy (pname, ((struct planet *) element->item)->name); */
/* 	  strcpy (ptype, */
/* 		  ((struct planet *) element->item)->pClass->typeClass); */
/* 	  element = element->listptr; */
/* 	} */
/*       while (element != NULL); */
/*       if (p != 0) */
/* 	{ */
/* 	  addint (buffer, p, ',', BUFF_SIZE); */
/* 	  addstring (buffer, pname, ',', BUFF_SIZE); */
/* 	  addstring (buffer, ptype, ':', BUFF_SIZE); */
/* 	} */
/*       else */
/* 	addstring (buffer, "", ':', BUFF_SIZE); */
/*     } */

/*   /\* */
/*    *This works but for testing purposes I'm taking it out */
/*    * if (element == NULL) */
/*    addstring(buffer, "", ':', BUFF_SIZE); */
/*    else */
/*    { */
/*    while (element != NULL) */
/*    { */
/*    p = ((struct planet *)element->item)->num; */
/*    fprintf(stderr, "\nbuilddescription: Sector %d found planet %d", sector, p);  */
/*    if (p != 0) */
/*    addint(buffer, p, ',', BUFF_SIZE); */
/*    element = element->listptr; */
/*    } */
/*    addstring(buffer, "", ':', BUFF_SIZE); */
/*    }*\/ */
/*   return; */
/* } */

void
bank_deposit (char *buffer, struct player *curplayer)
{
  int request = 0;

  request = popint (buffer, ":");
  fprintf (stderr, "bank_deposit: Player requesting (%d)\n", request);

  if (request > curplayer->credits)
    {
      strcpy (buffer, "BAD: Not enough credits on player.");
      return;
    }
  else
    {
      curplayer->credits = curplayer->credits - request;
      curplayer->bank_balance = curplayer->bank_balance + request;
      strcpy (buffer, "OK:Depsoit complete!");
    }
  return;
}

void
bank_balance (char *buffer, struct player *curplayer)
{
  int balance;
  strcpy (buffer, ":");
  addint (buffer, curplayer->bank_balance, ':', BUFF_SIZE);
  return;
}

void
bank_withdrawl (char *buffer, struct player *curplayer)
{
  int request = 0;

  request = popint (buffer, ":");
  if (curplayer->bank_balance < request)
    {
      strcpy (buffer, "BAD: Not enough credits in account.");
      return;
    }
  else
    {
      curplayer->bank_balance = curplayer->bank_balance - request;
      curplayer->credits = curplayer->credits + request;
      strcpy (buffer, "OK: Withdrawl complete!");
    }
  return;
}

void
whosonline (char *buffer)
{
  int playernum = 1;
  struct player *curplayer;

  strcpy (buffer, ":\0");
  while (players[playernum - 1] != NULL)
    {
      curplayer = players[playernum - 1];
      if (curplayer->loggedin)
	addint (buffer, curplayer->number, ',', BUFF_SIZE);
      playernum++;
    }
  strcat (buffer, ":\0");

}




int
intransit (json_t *json_data)
{
  struct player *curplayer;
  json_t *name_json;
  const char *player_name;

  // Retrieve the "name" value from the JSON object
  name_json = json_object_get (json_data, "name");

  // Check if the "name" key exists and is a string
  if (!json_is_string (name_json))
    {
      return (-1);
    }

  player_name = json_string_value (name_json);

  if ((curplayer =
       (struct player *) find (player_name, player, symbols,
			       HASH_LENGTH)) == NULL)
    return (-1);

  // gettimeofday is a function and you need a header for it.
  // Make sure you have #include <sys/time.h> at the top of your file.
  gettimeofday (&end, 0);

  if (curplayer->intransit == 1)
    {
      if ((end.tv_sec - curplayer->beginmove) >=
	  (shiptypes[ships[curplayer->ship - 1]->type - 1]->turns) *
	  WARP_WAIT)
	{
	  curplayer->intransit = 0;
	  curplayer->beginmove = 0;
	  curplayer->turns =
	    curplayer->turns - shiptypes[ships[curplayer->ship - 1]->type -
					 1]->turns;
	  insertitem (curplayer, player,
		      sectors[curplayer->movingto - 1]->playerlist, 1);
	  sendtosector (curplayer->movingto, curplayer->number, 1, 0);
	  return (0);
	}
      else
	{
	  return (1);
	}
    }
  else if (curplayer->beginmove == 0)
    {
      return (0);
    }
  return (0);
}


/*
  This is the auto pilot stuff, it is junk, and needs to be rewritten
*/
/* I'm commenting out all of this old junk just in case it's needed again.
   -Eryndil 4/9/2002
	All of it's deleted now since it's bad junk!
*/

void
findautoroute (int from, int to, char *buffer)
{
  int *length = (int *) malloc ((sectorcount + 1) * sizeof (int));
  int *prev = (int *) malloc ((sectorcount + 1) * sizeof (int));
  unsigned short *marked =
    (unsigned short *) malloc ((sectorcount + 1) * sizeof (unsigned short));
  unsigned short *unmarked =
    (unsigned short *) malloc ((sectorcount + 1) * sizeof (unsigned short));
  int shortest = 0, done = 0, i = 0, j = 0, counter = 0;
  int sectorlist[MAX_WARPS_PER_SECTOR];
  int backpath[100] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  };
  char temp[50];
  int nodefrom = innode (from);
  int nodeto = innode (to);

  if (nodefrom != nodeto)
    {
      if (configdata->numnodes != 1)
	{
	  if (from != nodes[nodefrom - 1]->portptr->location)
	    {
	      findautoroute (from, nodes[nodefrom - 1]->portptr->location,
			     buffer);
	    }
	  else
	    {
	      strcpy (buffer,
		      "BAD: You are already at the closest Node Station.");
	    }
	}
      else
	{
	  strcpy (buffer, "BAD: Something wrong serverside!");
	}
      return;
    }
  for (i = 0; i <= sectorcount; i++)
    {
      length[i] = 65536;
      prev[i] = 0;
      marked[i] = 0;
      unmarked[i] = 1;
    }
  length[from] = 0;
  while (!done)
    {
      shortest = 0;
      //Find sector with shortest hops to it thats unmarked
      for (counter = 1; counter <= sectorcount; counter++)
	{
	  if ((length[counter] < length[shortest])
	      && (unmarked[counter] == 1))
	    {
	      shortest = counter;
	    }
	}
      if (shortest == 0)
	{
	  done = 1;
	}
      else
	{
	  //Use that sector to calculate paths
	  i = shortest;
	  //Make a list of all adjacent sectors;
	  for (counter = 0; counter < MAX_WARPS_PER_SECTOR; counter++)
	    {
	      if (sectors[i - 1]->sectorptr[counter] != NULL)
		sectorlist[counter] =
		  sectors[i - 1]->sectorptr[counter]->number;
	      else
		sectorlist[counter] = 0;
	    }
	}
      //now using i as the sector under consideration
      for (counter = 0; counter < MAX_WARPS_PER_SECTOR; counter++)
	{
	  if (sectorlist[counter] == 0)
	    counter = MAX_WARPS_PER_SECTOR + 1;
	  else if (length[sectorlist[counter]] > (length[i] + 1))
	    {
	      length[sectorlist[counter]] = length[i] + 1;
	      prev[sectorlist[counter]] = i;
	    }
	}
      marked[i] = 1;
      unmarked[i] = 0;
    }
  //Now we have the shortest path. Using Dijkistra's Algorithm!
  //Now to make the list!
  counter = 1;
  backpath[0] = prev[to];
  while (prev[backpath[counter - 1]] != from)
    {
      backpath[counter] = prev[backpath[counter - 1]];
      counter++;
    }
  sprintf (buffer, ":%d", from);
  for (j = counter - 1; j >= 0; j--)
    {
      sprintf (temp, ",%d", backpath[j]);
      strcat (buffer, temp);
    }
  sprintf (temp, ",%d:", to);
  strcat (buffer, temp);

  free (length);
  free (prev);
  free (marked);
  free (unmarked);
}

/*
  end of the autopilot stuff (but probably not the end of junk ;)
*/

void
saveplayer (int pnumb, char *filename)
{
  char *intptr = (char *) malloc (50);
  char *buffer = (char *) malloc (BUFF_SIZE);
  char *stufftosave = (char *) malloc (BUFF_SIZE);
  FILE *playerfile;
  int loop = 0, len = 0;

  strcpy (buffer, "\0");
  strcpy (intptr, "\0");
  strcpy (stufftosave, "\0");

  //sprintf (intptr, "%d:", pnumb - 1);
  sprintf (stufftosave, "%d:", pnumb);
  if (players[pnumb - 1] == NULL)
    {
      strcat (stufftosave, "(Null):(Null):0:0:0:0:0:0:0:0:0:");
    }
  else
    {


      addstring (stufftosave, players[pnumb - 1]->name, ':', BUFF_SIZE);
      addstring (stufftosave, players[pnumb - 1]->passwd, ':', BUFF_SIZE);
      addint (stufftosave, players[pnumb - 1]->sector, ':', BUFF_SIZE);
      addint (stufftosave, players[pnumb - 1]->ship, ':', BUFF_SIZE);
      addint (stufftosave, players[pnumb - 1]->experience, ':', BUFF_SIZE);
      addint (stufftosave, players[pnumb - 1]->alignment, ':', BUFF_SIZE);
      addint (stufftosave, players[pnumb - 1]->turns, ':', BUFF_SIZE);
      sprintf (intptr, "%ld", players[pnumb - 1]->credits);
      addstring (stufftosave, intptr, ':', BUFF_SIZE);
      sprintf (intptr, "%ld", players[pnumb - 1]->bank_balance);
      addstring (stufftosave, intptr, ':', BUFF_SIZE);
      addint (stufftosave, players[pnumb - 1]->flags, ':', BUFF_SIZE);
    }
  //Now to use intptr to find where to place the person.
  sprintf (intptr, "%d:", pnumb - 1);
  len = strlen (stufftosave);
  //fprintf(stderr, "saveplayer: Player save string is (%s)", stufftosave);

  for (loop = 1; loop <= 199 - len; loop++)
    strcat (stufftosave, " ");
  strcat (stufftosave, "\n");


  playerfile = fopen (filename, "r+");
  if (playerfile == NULL)
    {
      fprintf (stderr, "\nsaveplayer: No playerfile! Saving to new one!");
      if ((pnumb - 1) != 0)
	{
	  fprintf (stderr,
		   "\nsaveplayer: Player is not player 1 for new save file!");
	  free (intptr);
	  free (buffer);
	  free (stufftosave);
	  return;
	}
      playerfile = fopen (filename, "w");
      fprintf (playerfile, "%s", stufftosave);
      fclose (playerfile);
      free (intptr);
      free (buffer);
      free (stufftosave);
      return;
    }
  if (pnumb == 1)
    {
      fprintf (playerfile, "%s", stufftosave);
      fclose (playerfile);
      free (intptr);
      free (buffer);
      free (stufftosave);
      return;
    }
  while (strncmp (buffer, intptr, strlen (intptr)) != 0)
    {
      strcpy (buffer, "\0");
      fgets (buffer, BUFF_SIZE, playerfile);
      if (strlen (buffer) == 0)
	return;
    }
  fprintf (playerfile, "%s", stufftosave);
  fflush (playerfile);
  fclose (playerfile);
  free (intptr);
  free (buffer);
  free (stufftosave);
}

void
saveship (int snumb, char *filename)
{
  char *intptr = (char *) malloc (10 * sizeof (char));
  char *buffer = (char *) malloc (BUFF_SIZE * sizeof (char));
  char *stufftosave = (char *) malloc (BUFF_SIZE * sizeof (char));
  FILE *playerfile;
  int loop = 0, len;

  strcpy (buffer, "\0");
  strcpy (intptr, "\0");
  strcpy (stufftosave, "\0");

  sprintf (intptr, "%d:", snumb - 1);
  sprintf (stufftosave, "%d:", snumb);
  if (ships[snumb - 1] == NULL)
    {
      strcat (stufftosave, "(Null):0:0:0:0:0:0:0:0:0:0:0:");
    }
  else
    {
      addstring (stufftosave, ships[snumb - 1]->name, ':', BUFF_SIZE);
      addint (stufftosave, ships[snumb - 1]->type, ':', BUFF_SIZE);
      addint (stufftosave, ships[snumb - 1]->location, ':', BUFF_SIZE);
      addint (stufftosave, ships[snumb - 1]->fighters, ':', BUFF_SIZE);
      addint (stufftosave, ships[snumb - 1]->shields, ':', BUFF_SIZE);
      addint (stufftosave, ships[snumb - 1]->holds, ':', BUFF_SIZE);
      addint (stufftosave, ships[snumb - 1]->colonists, ':', BUFF_SIZE);
      addint (stufftosave, ships[snumb - 1]->equipment, ':', BUFF_SIZE);
      addint (stufftosave, ships[snumb - 1]->organics, ':', BUFF_SIZE);
      addint (stufftosave, ships[snumb - 1]->ore, ':', BUFF_SIZE);
      addint (stufftosave, ships[snumb - 1]->owner, ':', BUFF_SIZE);
      addint (stufftosave, ships[snumb - 1]->flags, ':', BUFF_SIZE);
      addint (stufftosave, ships[snumb - 1]->onplanet, ':', BUFF_SIZE);
    }
  len = strlen (stufftosave);
  for (loop = 1; loop <= 199 - len; loop++)	//This puts a buffer of space in the save
    strcat (stufftosave, " ");	//file so things don't get overwritten
  strcat (stufftosave, "\n");	//when saving.

  playerfile = fopen (filename, "r+");
  if (playerfile == NULL)
    {
      fprintf (stderr, "\nsaveship: No ship file! Saving to new one!");
      if ((snumb - 1) != 0)
	{
	  fprintf (stderr, "\nsaveship: Ship is not #1 for new save file!");
	  exit (-1);
	}
      playerfile = fopen (filename, "w");
      fprintf (playerfile, "%s", stufftosave);
      fclose (playerfile);
      free (intptr);
      free (buffer);
      free (stufftosave);
      return;
    }
  if (snumb == 1)
    {
      fprintf (playerfile, "%s", stufftosave);
      fclose (playerfile);
      free (intptr);
      free (buffer);
      free (stufftosave);
      return;
    }
  while (strncmp (buffer, intptr, strlen (intptr)) != 0)
    {
      strcpy (buffer, "\0");
      fgets (buffer, BUFF_SIZE, playerfile);
      if (strlen (buffer) == 0)
	return;
    }
  fprintf (playerfile, "%s", stufftosave);
  fclose (playerfile);
  free (intptr);
  free (buffer);
  free (stufftosave);

}

void
saveallports (char *filename)
{
  char *intptr = (char *) malloc (10);
  char *buffer = (char *) malloc (BUFF_SIZE);
  char *stufftosave = (char *) malloc (BUFF_SIZE);
  FILE *portfile;
  int loop = 0, len;
  int portnumb = 1;

  portfile = fopen (filename, "w");
  while (ports[portnumb - 1] != NULL)
    {
      strcpy (stufftosave, "\0");
      sprintf (intptr, "%d", portnumb - 1);
      sprintf (stufftosave, "%d:", portnumb);
      addstring (stufftosave, ports[portnumb - 1]->name, ':', BUFF_SIZE);
      addint (stufftosave, ports[portnumb - 1]->location, ':', BUFF_SIZE);
      addint (stufftosave, ports[portnumb - 1]->maxproduct[0], ':',
	      BUFF_SIZE);
      addint (stufftosave, ports[portnumb - 1]->maxproduct[1], ':',
	      BUFF_SIZE);
      addint (stufftosave, ports[portnumb - 1]->maxproduct[2], ':',
	      BUFF_SIZE);
      addint (stufftosave, ports[portnumb - 1]->product[0], ':', BUFF_SIZE);
      addint (stufftosave, ports[portnumb - 1]->product[1], ':', BUFF_SIZE);
      addint (stufftosave, ports[portnumb - 1]->product[2], ':', BUFF_SIZE);
      addint (stufftosave, ports[portnumb - 1]->credits, ':', BUFF_SIZE);
      addint (stufftosave, ports[portnumb - 1]->type, ':', BUFF_SIZE);
      addint (stufftosave, ports[portnumb - 1]->invisible, ':', BUFF_SIZE);

      len = strlen (stufftosave);
      for (loop = 1; loop <= 199 - len; loop++)	//This puts a buffer of space in the save
	strcat (stufftosave, " ");	//file so things don't get overwritten
      strcat (stufftosave, "\n");	//when saving.
      //fprintf(stderr, "\nsaveallports: Saving port '%s'", stufftosave);
      //fflush(stderr);

      fprintf (portfile, "%s", stufftosave);
      portnumb++;
    }
  fclose (portfile);
  free (intptr);
  free (buffer);
  free (stufftosave);

}

void
planettake (char *buffer, struct player *curplayer)
{
  struct planet *curplanet;
  struct ship *curship;
  int amt;
  int choice;
  int emptyholds;

  choice = popint (buffer, ":");
  amt = popint (buffer, ":");
  curship = ships[curplayer->ship - 1];
  curplanet = planets[curship->onplanet - 1];
  emptyholds = curship->holds - curship->ore - curship->organics
    - curship->equipment - curship->colonists;
  if (emptyholds < 0)
    {
      strcpy (buffer, "BAD: Ship has negative emptyholds!");
      fprintf (stderr, "planettake: Ship (%d) has negative emptyholds!",
	       curship->number);
      return;
    }
  else if (emptyholds == 0)
    {
      strcpy (buffer, "BAD: You don't have any empty holds!");
      return;
    }
  //For choices
  //0 ore, 1 org, 2 equip, 3 col in ore, 4 col in org, 5 col in equip
  //6 figs, 7 creds, 8 shields
  switch (choice)
    {
    case 0:
      if (amt > emptyholds)
	{
	  strcpy (buffer, "BAD: You don't have enought empty holds!");
	  return;
	}
      if (amt > curplanet->fuel)
	{
	  strcpy (buffer, "BAD: Not enough ore on planet!");
	  return;
	}
      curplanet->fuel = curplanet->fuel - amt;
      curship->ore = curship->ore + amt;
      break;
    case 1:
      if (amt > emptyholds)
	{
	  strcpy (buffer, "BAD: You don't have enought empty holds!");
	  return;
	}
      if (amt > curplanet->organics)
	{
	  strcpy (buffer, "BAD: Not enough organics on planet!");
	  return;
	}
      curplanet->organics = curplanet->organics - amt;
      curship->organics = curship->organics + amt;
      break;
    case 2:
      if (amt > emptyholds)
	{
	  strcpy (buffer, "BAD: You don't have enought empty holds!");
	  return;
	}
      if (amt > curplanet->equipment)
	{
	  strcpy (buffer, "BAD: Not enough equipment on planet!");
	  return;
	}
      curplanet->equipment = curplanet->equipment - amt;
      curship->equipment = curship->equipment + amt;
      break;
    case 3:
      if (amt > emptyholds)
	{
	  strcpy (buffer, "BAD: You don't have enought empty holds!");
	  return;
	}
      if (amt > curplanet->fuelColonist)
	{
	  strcpy (buffer, "BAD: Not enough ore Colonists on planet!");
	  return;
	}
      curplanet->fuelColonist = curplanet->fuelColonist - amt;
      curship->colonists = curship->colonists + amt;
      break;
    case 4:
      if (amt > emptyholds)
	{
	  strcpy (buffer, "BAD: You don't have enought empty holds!");
	  return;
	}
      if (amt > curplanet->organicsColonist)
	{
	  strcpy (buffer, "BAD: Not enough organic colonists on planet!");
	  return;
	}
      curplanet->organicsColonist = curplanet->organicsColonist - amt;
      curship->colonists = curship->colonists + amt;
      break;
    case 5:
      if (amt > emptyholds)
	{
	  strcpy (buffer, "BAD: You don't have enought empty holds!");
	  return;
	}
      if (amt > curplanet->equipmentColonist)
	{
	  strcpy (buffer, "BAD: Not enough equipment colonists on planet!");
	  return;
	}
      curplanet->equipmentColonist = curplanet->equipmentColonist - amt;
      curship->colonists = curship->colonists + amt;
      break;
    case 6:
      if (amt >
	  (shiptypes[curship->type - 1]->maxfighters - curship->fighters))
	{
	  strcpy (buffer, "BAD: Your ship can't hold that many fighters!");
	  return;
	}
      if (amt > curplanet->fighters)
	{
	  strcpy (buffer, "BAD: The planet doesn't have that many fighters!");
	  return;
	}
      curplanet->fighters = curplanet->fighters - amt;
      curship->fighters = curship->fighters + amt;
      break;
    case 7:
      if (curplanet->citdl->level == 0)
	{
	  strcpy (buffer, "BAD: You need a citadel to do that!");
	  return;
	}
      if (amt > curplanet->citdl->treasury)
	{
	  strcpy (buffer, "BAD: The treasury doesn't have that much!");
	  return;
	}
      curplanet->citdl->treasury = curplanet->citdl->treasury - amt;
      curplayer->credits = curplayer->credits + amt;
      break;
    case 8:
      if (curplanet->citdl->level < 5)
	{
	  strcpy (buffer, "BAD: You need a better citadel to do that!");
	  return;
	}
      if (amt > curplanet->citdl->planetaryShields)
	{
	  strcpy (buffer, "BAD: The shields don't have that much!");
	  return;
	}
      if (amt * 10 >
	  (shiptypes[curship->type - 1]->maxshields - curship->shields))
	{
	  strcpy (buffer, "BAD: Your ship can't carry that many!");
	  return;
	}
      curplanet->citdl->planetaryShields =
	curplanet->citdl->planetaryShields - amt;
      curship->shields = curship->shields + 10 * amt;
      break;
    default:
      strcpy (buffer, "BAD: Invalid TAKE command!");
      return;
    }
  strcpy (buffer, "OK: Taking stuff from the planet!");
}

void
planetleave (char *buffer, struct player *curplayer)
{
  struct planet *curplanet;
  struct ship *curship;
  int amt;
  int choice;
  int emptyholds;

  choice = popint (buffer, ":");
  amt = popint (buffer, ":");
  curship = ships[curplayer->ship - 1];
  curplanet = planets[curship->onplanet - 1];
  emptyholds = curship->holds - curship->ore - curship->organics
    - curship->equipment - curship->colonists;
  if (emptyholds < 0)
    {
      strcpy (buffer, "BAD: Ship has negative emptyholds!");
      fprintf (stderr, "planettake: Ship (%d) has negative emptyholds!",
	       curship->number);
      return;
    }
  //For choices
  //0 ore, 1 org, 2 equip, 3 col in ore, 4 col in org, 5 col in equip
  //6 figs, 7 creds, 8 shields
  switch (choice)
    {
    case 0:
      if (amt > curship->ore)
	{
	  strcpy (buffer, "BAD: You don't have that much ore!");
	  return;
	}
      if ((curplanet->fuel + amt) > curplanet->pClass->maxore)
	{
	  strcpy (buffer, "BAD: Planet can't hold that much ore!");
	  return;
	}
      curplanet->fuel = curplanet->fuel + amt;
      curship->ore = curship->ore - amt;
      break;
    case 1:
      if (amt > curship->organics)
	{
	  strcpy (buffer, "BAD: You don't have enough organics!");
	  return;
	}
      if ((curplanet->organics + amt) > curplanet->pClass->maxorganics)
	{
	  strcpy (buffer, "BAD: Planet can't hold that many organics!");
	  return;
	}
      curplanet->organics = curplanet->organics + amt;
      curship->organics = curship->organics - amt;
      break;
    case 2:
      if (amt > curship->equipment)
	{
	  strcpy (buffer, "BAD: You don't have that much equipment!");
	  return;
	}
      if ((curplanet->equipment + amt) > curplanet->pClass->maxequipment)
	{
	  strcpy (buffer, "BAD: Planet can't hold that much equipment!");
	  return;
	}
      curplanet->equipment = curplanet->equipment + amt;
      curship->equipment = curship->equipment - amt;
      break;
    case 3:
      if (amt > curship->colonists)
	{
	  strcpy (buffer, "BAD: You don't have that many colonists");
	  return;
	}
      if ((amt + curplanet->fuelColonist) > curplanet->pClass->maxColonist[0])
	{
	  strcpy (buffer, "BAD: Planet can't hold that many ore colonists!");
	  return;
	}
      curplanet->fuelColonist = curplanet->fuelColonist + amt;
      curship->colonists = curship->colonists - amt;
      break;
    case 4:
      if (amt > curship->colonists)
	{
	  strcpy (buffer, "BAD: You don't have that many colonists");
	  return;
	}
      if ((amt + curplanet->organicsColonist) >
	  curplanet->pClass->maxColonist[1])
	{
	  strcpy (buffer,
		  "BAD: Planet can't hold that many organics colonists!");
	  return;
	}
      curplanet->organicsColonist = curplanet->organicsColonist + amt;
      curship->colonists = curship->colonists - amt;
      break;
    case 5:
      if (amt > curship->colonists)
	{
	  strcpy (buffer, "BAD: You don't have that many colonists");
	  return;
	}
      if ((amt + curplanet->equipmentColonist) >
	  curplanet->pClass->maxColonist[2])
	{
	  strcpy (buffer,
		  "BAD: Planet can't hold that many equipment colonists!");
	  return;
	}
      curplanet->equipmentColonist = curplanet->equipmentColonist + amt;
      curship->colonists = curship->colonists - amt;
      break;
    case 6:
      if (amt > curship->fighters)
	{
	  strcpy (buffer, "BAD: Your ship doesn't hold that many fighters!");
	  return;
	}
      if ((amt + curplanet->fighters) > curplanet->pClass->maxfighters)
	{
	  strcpy (buffer, "BAD: The planet can't hold that many fighters!");
	  return;
	}
      curplanet->fighters = curplanet->fighters + amt;
      curship->fighters = curship->fighters - amt;
      break;
    case 7:
      if (curplanet->citdl->level == 0)
	{
	  strcpy (buffer, "BAD: You need a citadel to do that!");
	  return;
	}
      if (amt > curplayer->credits)
	{
	  strcpy (buffer, "BAD: You don't have that much!");
	  return;
	}
      curplanet->citdl->treasury = curplanet->citdl->treasury + amt;
      curplayer->credits = curplayer->credits - amt;
      break;
    case 8:
      if (curplanet->citdl->level < 5)
	{
	  strcpy (buffer, "BAD: You need a better citadel to do that!");
	  return;
	}
      //Check max planet shields!
      if (amt * 10 > curship->shields)
	{
	  strcpy (buffer, "BAD: Your ship doesn't have that many shields!");
	  return;
	}
      curplanet->citdl->planetaryShields =
	curplanet->citdl->planetaryShields + amt;
      curship->shields = curship->shields - 10 * amt;
      break;
    default:
      strcpy (buffer, "BAD: Invalid LEAVE command!");
      return;
    }
  strcpy (buffer, "OK: Leaving stuff on the planet!");
}

void
planetupgrade (char *buffer, struct planet *curplanet)
{
  int upgrade = 0;
  time_t timenow;

  upgrade = popint (buffer, ":");

  strcpy (buffer, "\0");
  timenow = time (NULL);
  if (curplanet->citdl->upgradestart != 0)
    {
      addint (buffer,
	      (curplanet->citdl->upgradestart - timenow) / (3600 * 24), ':',
	      BUFF_SIZE);
    }
  else
    addint (buffer, 0, ':', BUFF_SIZE);
  addint (buffer,
	  curplanet->pClass->citadelUpgradeColonist[curplanet->citdl->level],
	  ':', BUFF_SIZE);
  addint (buffer,
	  curplanet->pClass->citadelUpgradeOre[curplanet->citdl->level], ':',
	  BUFF_SIZE);
  addint (buffer,
	  curplanet->pClass->citadelUpgradeOrganics[curplanet->citdl->level],
	  ':', BUFF_SIZE);
  addint (buffer,
	  curplanet->pClass->citadelUpgradeEquipment[curplanet->citdl->level],
	  ':', BUFF_SIZE);
  addint (buffer,
	  curplanet->pClass->citadelUpgradeTime[curplanet->citdl->level], ':',
	  BUFF_SIZE);
  if ((upgrade == 1) && (curplanet->citdl->upgradestart == 0))
    {
      if ((curplanet->fuelColonist + curplanet->organicsColonist +
	   curplanet->equipmentColonist) <
	  curplanet->pClass->citadelUpgradeColonist[curplanet->citdl->level] /
	  1000)
	{
	  strcpy (buffer, "BAD: Not enough Colonists");
	  return;
	}
      if (curplanet->fuel <
	  curplanet->pClass->citadelUpgradeOre[curplanet->citdl->level])
	{
	  strcpy (buffer, "BAD: Not enough Ore");
	  return;
	}
      if (curplanet->organics <
	  curplanet->pClass->citadelUpgradeOrganics[curplanet->citdl->level])
	{
	  strcpy (buffer, "BAD: Not enough Organics");
	  return;
	}
      if (curplanet->equipment <
	  curplanet->pClass->citadelUpgradeEquipment[curplanet->citdl->level])
	{
	  strcpy (buffer, "BAD: Not enough Equipment");
	  return;
	}
      curplanet->citdl->upgradestart = timenow;
      curplanet->fuel = curplanet->fuel -
	curplanet->pClass->citadelUpgradeOre[curplanet->citdl->level];
      curplanet->organics = curplanet->organics -
	curplanet->pClass->citadelUpgradeOrganics[curplanet->citdl->level];
      curplanet->equipment = curplanet->equipment -
	curplanet->pClass->citadelUpgradeEquipment[curplanet->citdl->level];
      strcpy (buffer, "OK: Staring Citadel upgrade!");
    }
}



void
buildgameinfo (char *buffer)
{
  time_t datenow;
  time_t difference;
  int numports = 0;
  int numplayers = 0;
  int numgood = 0;
  float percent;
  unsigned long portworth = 0;
  int numplanets = 0;
  int numcitadels = 0;
  int stardocksector = 0;
  int index = 0;

  for (index = 0; index < configdata->max_players; index++)
    {
      if (players[index] != NULL)
	{
	  numplayers++;
	  if (players[index]->alignment > 0)
	    numgood++;
	}
    }
  for (index = 0; index < configdata->max_ports; index++)
    {
      if (ports[index] != NULL)
	{
	  numports++;
	  portworth = portworth + ports[index]->credits;
	  if (ports[index]->type == 9)
	    stardocksector = ports[index]->location;
	}
    }
  for (index = 0; index < configdata->max_total_planets; index++)
    {
      if (planets[index] != NULL)
	{
	  numplanets++;
	  if (planets[index]->citdl->level != 0)
	    numcitadels++;
	}
    }
  datenow = time (NULL);
  difference = (datenow - configdata->bangdate) / (24 * 3600);

  buffer[0] = '\0';
  addint (buffer, sectorcount, ':', BUFF_SIZE);
  addint (buffer, configdata->turnsperday, ':', BUFF_SIZE);
  addint (buffer, configdata->startingcredits, ':', BUFF_SIZE);
  addint (buffer, configdata->startingfighters, ':', BUFF_SIZE);
  addint (buffer, configdata->startingholds, ':', BUFF_SIZE);
  addint (buffer, configdata->max_players, ':', BUFF_SIZE);
  addint (buffer, numplayers, ':', BUFF_SIZE);
  percent = ((float) numgood / (float) numplayers) * 100;
  addint (buffer, percent, ':', BUFF_SIZE);
  addint (buffer, configdata->max_ports, ':', BUFF_SIZE);
  addint (buffer, numports, ':', BUFF_SIZE);
  addint (buffer, portworth, ':', BUFF_SIZE);
  addint (buffer, configdata->max_total_planets, ':', BUFF_SIZE);
  addint (buffer, configdata->max_safe_planets, ':', BUFF_SIZE);
  addint (buffer, numplanets, ':', BUFF_SIZE);
  percent = ((float) numcitadels / (float) numplanets) * 100;
  addint (buffer, percent, ':', BUFF_SIZE);
  addint (buffer, configdata->numnodes, ':', BUFF_SIZE);
  addint (buffer, stardocksector, ':', BUFF_SIZE);
  addint (buffer, difference, ':', BUFF_SIZE);
}


json_t *
buildtotalinfo (int pnumb)
{
  json_t *json_obj = json_object();
  if (!json_obj) {
    fprintf(stderr, "Failed to create JSON object.\n");
    return NULL;
  }

  // Add player information
  json_object_set_new(json_obj, "player_number", json_integer(players[pnumb - 1]->number));
  json_object_set_new(json_obj, "player_name", json_string(players[pnumb - 1]->name));
  json_object_set_new(json_obj, "ship_number", json_integer(players[pnumb - 1]->ship));
  json_object_set_new(json_obj, "experience", json_integer(players[pnumb - 1]->experience));
  json_object_set_new(json_obj, "alignment", json_integer(players[pnumb - 1]->alignment));
  json_object_set_new(json_obj, "turns", json_integer(players[pnumb - 1]->turns));
  json_object_set_new(json_obj, "credits", json_integer(players[pnumb - 1]->credits));
  
  // Add ship information
  json_object_set_new(json_obj, "ship_number", json_integer(ships[players[pnumb - 1]->ship - 1]->number));
  json_object_set_new(json_obj, "ship_name", json_string(ships[players[pnumb - 1]->ship - 1]->name));
  json_object_set_new(json_obj, "ship_type_name", json_string(shiptypes[ships[players[pnumb - 1]->ship - 1]->type - 1]->name));
  json_object_set_new(json_obj, "fighters", json_integer(ships[players[pnumb - 1]->ship - 1]->fighters));
  json_object_set_new(json_obj, "shields", json_integer(ships[players[pnumb - 1]->ship - 1]->shields));
  json_object_set_new(json_obj, "holds", json_integer(ships[players[pnumb - 1]->ship - 1]->holds));
  json_object_set_new(json_obj, "colonists", json_integer(ships[players[pnumb - 1]->ship - 1]->colonists));
  json_object_set_new(json_obj, "equipment", json_integer(ships[players[pnumb - 1]->ship - 1]->equipment));
  json_object_set_new(json_obj, "organics", json_integer(ships[players[pnumb - 1]->ship - 1]->organics));
  json_object_set_new(json_obj, "ore", json_integer(ships[players[pnumb - 1]->ship - 1]->ore));
  json_object_set_new(json_obj, "owner", json_integer(ships[players[pnumb - 1]->ship - 1]->owner));
  
  if (intransit(NULL)) {
    json_object_set_new(json_obj, "location", json_integer(0));
  } else {
    json_object_set_new(json_obj, "location", json_integer(ships[players[pnumb - 1]->ship - 1]->location));
  }

  json_object_set_new(json_obj, "ship_type_turns", json_integer(shiptypes[ships[players[pnumb - 1]->ship - 1]->type - 1]->turns));

  return json_obj;
}

void
sellship (char *buffer, struct player *curplayer)
{
  const int price_per_fighter = 218;
  const int price_per_shield = 131;
  const int base_hold_price = 249;
  const int hold_increment = 20;
  char shipname[300] = "\0";
  int shipnum = 0;

  struct ship *curship;
  const float multiplier = 0.75;
  int total = 0;

  curship = ships[curplayer->ship - 1];
  curplayer->sector = curship->location;
  priceship (buffer, curplayer);
  total = popint (buffer, ":");
  curplayer->credits = curplayer->credits + total;
  buffer[0] = '\0';
  addint (buffer, total, ':', BUFF_SIZE);
  strcpy (shipname, curship->name);
  shipnum = curship->number;
  free (curship->name);
  delete (shipname, ship, symbols, HASH_LENGTH);
  curplayer->ship = 0;
  ships[shipnum - 1] = NULL;
  return;
}

void
priceship (char *buffer, struct player *curplayer)
{
  const int price_per_fighter = 218;
  const int price_per_shield = 131;
  const int base_hold_price = 249;
  const int hold_increment = 20;
  char *temp = (char *) malloc (sizeof (char) * BUFF_SIZE);

  int holds_to_sell = 0;
  int price_holds = 0;
  struct ship *curship;
  const float multiplier = 0.75;
  int total = 0;

  curship = ships[curplayer->ship - 1];
  holds_to_sell = curship->holds - shiptypes[curship->type - 1]->initialholds;
  //Taken from do_ship_upgrade
  price_holds = base_hold_price * holds_to_sell +
    hold_increment * holds_to_sell * shiptypes[curship->type -
					       1]->initialholds;

  total = total + multiplier * (float) shiptypes[curship->type - 1]->basecost;
  strcpy (temp, "Ship Basecost,");
  addint (temp, multiplier * (float) shiptypes[curship->type - 1]->basecost,
	  ':', BUFF_SIZE);
  if (curship->holds != 0)
    {
      addstring (temp, "Ship Holds Value", ',', BUFF_SIZE);
      addint (temp, multiplier * (float) price_holds, ':', BUFF_SIZE);
      total = total + multiplier * (float) price_holds;
    }
  if (curship->fighters != 0)
    {
      addstring (temp, "Fighters", ',', BUFF_SIZE);
      addint (temp, multiplier * (float) curship->fighters, ':', BUFF_SIZE);
      total =
	total + multiplier * (float) (price_per_fighter * curship->fighters);
    }
  if (curship->shields != 0)
    {
      addstring (temp, "Shields", ',', BUFF_SIZE);
      addint (temp, multiplier * (float) curship->shields, ':', BUFF_SIZE);
      total =
	total + multiplier * (float) (price_per_shield * curship->shields);
    }
  //Add hardware in here!

  strcpy (buffer, ":");
  addint (buffer, total, ':', BUFF_SIZE);
  strcat (buffer, temp);
  return;

}

void
listships (char *buffer)
{
  int index = 0;
  for (index = 0; index <= configdata->ship_type_count - 1; index++)
    {
      addstring (buffer, shiptypes[index]->name, ',', BUFF_SIZE);
      addint (buffer, shiptypes[index]->basecost, ':', BUFF_SIZE);
    }
}

void
buyship (char *buffer, struct player *curplayer)
{
  int type = 0;
  int manned = 0;
  char name[500];
  int i = 0;
  int done = 0;
  struct ship *curship = NULL;

  type = popint (buffer, ":");
  manned = popint (buffer, ":");
  popstring (buffer, name, ":", BUFF_SIZE);
  if ((manned == 1) && (curplayer->ship != 0))
    {
      strcpy (buffer,
	      "BAD: You can't man a new ship w/o selling the current one.");
      return;
    }
  if (curplayer->credits < shiptypes[type - 1]->basecost)
    {
      strcpy (buffer, "BAD: You don't have enough credits!");
      return;
    }
  if ((curship =
       (struct ship *) find (name, ship, symbols, HASH_LENGTH)) != NULL)
    {
      fprintf (stderr, "\nbuyship: duplicate shipname!");
      strcpy (buffer, "BAD: Another ship has this name already!");
      return;
    }
  if ((curship =
       (struct ship *) insert (name, ship, symbols, HASH_LENGTH)) == NULL)
    {
      //This should never be reached because of the previous if.
      fprintf (stderr, "buyship: duplicate shipanme");
      strcpy (buffer, "BAD: Another ship has this name already!");
      return;
    }
  while (!done)
    {
      if (i > configdata->max_ships - 1)
	{
	  done = 1;
	  strcpy (buffer, "BAD: No more ships allowable!");
	  fprintf (stderr, "\nbuyship: Max ships reached!");
	  return;
	}
      else
	{
	  if (ships[i] == NULL)
	    {
	      ships[i] = curship;
	      curship->number = i + 1;
	      done = 1;
	    }
	}
      i++;
    }
  curship->name = (char *) malloc (strlen (name) + 1);
  strcpy (curship->name, name);
  curship->location = curplayer->sector;
  curship->type = type;
  curship->shields = 0;
  curship->fighters = 0;
  curship->holds = shiptypes[type - 1]->initialholds;
  curship->colonists = 0;
  curship->equipment = 0;
  curship->organics = 0;
  curship->ore = 0;
  curship->owner = curplayer->number;
  if (manned == 1)
    {
      curship->flags = 0 | S_STARDOCK | S_PORTED;
      curship->ported = 0;
      curplayer->ship = curship->number;
      curplayer->sector = 0;
      strcpy (buffer, "OK: You are manning a new ship!");
    }
  else
    {
      curship->flags = 0;
      curship->ported = 0;
      //I hope this doesn't break
      insertitem (curship, ship, sectors[curship->location]->shiplist, 1);
      strcpy (buffer, "OK: You own an unmanned ship in this sector");
    }
  curplayer->credits = curplayer->credits - shiptypes[type - 1]->basecost;
  return;
}


void
do_ship_upgrade (struct player *curplayer, char *buffer, struct ship *curship)
{
  const int base_hold_price = 249;
  const int price_per_shield = 131;
  const int price_per_fighter = 218;
  const int hold_increment = 20;	//This is the price for how much each new hold
  //gets incremented
  //4 for holds, 5 for shields, 6 for fighters, 7 for all three
  int product = 0;
  int amount = 0;
  int holds = 0;
  int shields = 0;
  int fighters = 0;
  int buying = 0;
  int total_price = 0;
  int total_holds = 0;		//This is the total number of holds they are going
  //to have when finished purchasing. 
  int price_holds = 0;		//Since the price for holds is complicated 
  //This is the price of the holds the player is buying

  if (sectors[curship->location - 1]->portptr == NULL)
    {
      strcpy (buffer, "BAD: No port in this sector!");
      return;
    }
  else if (sectors[curship->location - 1]->portptr->type != 0 &&
	   sectors[curship->location - 1]->portptr->type != 9)
    {
      strcpy (buffer, "BAD: No Class 0 or 9 port in this sector!");
      return;
    }
  product = popint (buffer, ":");
  amount = popint (buffer, ":");
  buying = popint (buffer, ":");
  //If buying is 1 then they're buying. Otherwise they ain't buying

  switch (product)
    {
    case 4:
      holds = amount;
      if (buying == 1)
	{
	  if ((curship->holds + amount) >
	      shiptypes[curship->type - 1]->maxholds)
	    {
	      holds = shiptypes[curship->type - 1]->maxholds - curship->holds;
	    }
	}
      break;
    case 5:
      shields = amount;
      if (buying == 1)
	{
	  if ((curship->shields + amount) >
	      shiptypes[curship->type - 1]->maxshields)
	    {
	      shields =
		shiptypes[curship->type - 1]->maxshields - curship->shields;
	    }
	}
      break;
    case 6:
      fighters = amount;
      if (buying == 1)
	{
	  if ((curship->fighters + amount) >
	      shiptypes[curship->type - 1]->maxfighters)
	    {
	      fighters =
		shiptypes[curship->type - 1]->maxfighters - curship->fighters;
	    }
	}
      break;
    case 7:
      holds = amount;
      shields = amount;
      fighters = amount;
      if (buying == 1)
	{
	  if ((curship->holds + amount) >
	      shiptypes[curship->type - 1]->maxholds)
	    {
	      holds = shiptypes[curship->type - 1]->maxholds - curship->holds;
	    }
	  if ((curship->shields + amount) >
	      shiptypes[curship->type - 1]->maxshields)
	    {
	      shields =
		shiptypes[curship->type - 1]->maxshields - curship->shields;
	    }
	  if ((curship->fighters + amount) >
	      shiptypes[curship->type - 1]->maxfighters)
	    {
	      fighters =
		shiptypes[curship->type - 1]->maxfighters - curship->fighters;
	    }
	}
      else if (buying == 2)
	{
	  holds =
	    min (curplayer->credits /
		 (base_hold_price + hold_increment * curship->holds),
		 shiptypes[curship->type - 1]->maxholds - curship->holds);
	  fighters =
	    min (curplayer->credits / price_per_fighter,
		 shiptypes[curship->type - 1]->maxfighters -
		 curship->fighters);
	  shields =
	    min (curplayer->credits / price_per_shield,
		 shiptypes[curship->type - 1]->maxshields - curship->shields);
	}
      break;
    default:
      strcpy (buffer, "BAD: Invalid Product Selection");
      buying = -1;
      break;
    }
  //The price of X number of total holds is from the following forumla
  //price(X) = base_hold_price*X + hold_increment*(((X-1)*X)/2)
  //And after math the price that the player is going to play for (holds)
  //more holds is as follows
  price_holds =
    base_hold_price * holds + hold_increment * holds * curship->holds;

  if (buying == 1)
    {
      total_price = price_per_shield * shields + price_per_fighter * fighters
	+ price_holds;

      if (total_price > curplayer->credits)
	{
	  strcpy (buffer, "BAD: Not enough credits");
	  buying = -1;
	}
      else
	{
	  curplayer->credits = curplayer->credits - total_price;
	  curship->holds = curship->holds + holds;
	  curship->shields = curship->shields + shields;
	  curship->fighters = curship->fighters + fighters;
	}
    }
  if (buying != -1)
    {
      strcpy (buffer, ":");
      addint (buffer, price_holds, ',', BUFF_SIZE);
      addint (buffer, holds, ':', BUFF_SIZE);
      addint (buffer, price_per_shield * shields, ',', BUFF_SIZE);
      addint (buffer, shields, ':', BUFF_SIZE);
      addint (buffer, price_per_fighter * fighters, ',', BUFF_SIZE);
      addint (buffer, fighters, ':', BUFF_SIZE);
    }
}



void
trading (struct player *curplayer, struct port *curport, char *buffer,
	 struct ship *curship)
{
  /*
   * If port is selling we want the first price offered to be
   * offered = (int)sell_base[product]*exp(2)*exp(-maxtype/3000)*exp(-current/maxtype)
   * If port is buying we want the first price offered to be
   * offered = (int)buy_base[product]*exp(maxtype/3000)*exp(-current/maxtype)
   *
   * For those who don't know. the exp(2) is from exp(1)*exp(1) which comes
   * from normalizing the two exponentials in the selling..
   * In the buying the normalization of the exponentials is exp(-1) * exp(1)
   * which is 1.
   *
   * Using the Box-Muller Polar Method for Standard Normal Variables
   * The function box_muller() was obtained from
   * http://www.taygeta.com/pub/c/boxmuller.c
   * on 3/10/2001 
   * because log() has problems evaluating numbers close to zero.
   * 
   * 
   */
  int offered = 0;
  int playerprice = 0;
  int product = -1;
  int type = 0;			//For making life easier
  int holds = 0;
  int accepted = 0;
  int xpgained = 0;
  float mean = 0;
  float deviation = 0;
  double maxproduct;		//Since 2880/3000 = 0 instead of .96
  double curproduct;		//Since 2880/2880 = 0 instead of .96
  float firstprice;
  float lastprice;
  product = popint (buffer, ":");
  holds = popint (buffer, ":");
  playerprice = popint (buffer, ":");
  maxproduct = curport->maxproduct[product];
  curproduct = curport->product[product];
  firstprice = curplayer->firstprice;
  lastprice = curplayer->lastprice;

  if (curplayer->lastprice == 0)
    {
      //0 for Ore, 1 for organics, 2 for equipment, 3 for credits
      if (product != 3)
	{
	  if (portconversion[curport->type][product] == 'B')
	    {
	      mean =
		holds * buy_base_prices[product] * exp (maxproduct / 3000) *
		exp (-(1 - curproduct / maxproduct));
	      if ((curproduct + holds) > maxproduct)
		{
		  strcpy (buffer, "BAD: Port cannot buy more");	//To keep from going out of bounds
		  return;
		}
	      //If we're not getting a test price
	      if (playerprice != -1)
		{
		  if (product == 0)
		    {
		      if (curship->ore != holds)
			{
			  strcpy (buffer,
				  "BAD: You don't have that much ore!");
			  return;
			}
		    }
		  else if (product == 1)
		    {
		      if (curship->organics != holds)
			{
			  strcpy (buffer,
				  "BAD: You don't have that much organics!");
			}
		    }
		  else if (product == 2)
		    {
		      if (curship->equipment != holds)
			{
			  strcpy (buffer,
				  "BAD: You don't have that much equipment!");
			}
		    }
		}
	    }
	  else if (portconversion[curport->type][product] == 'S')
	    {
	      mean =
		holds * sell_base_prices[product] * exp (2) *
		exp (-maxproduct / 3000) * exp (-curproduct / maxproduct);
	      if ((curproduct - holds) < 0)
		{
		  strcpy (buffer, "BAD: Port cannot sell more");	//To keep from going out of bounds
		  return;
		}
	      if (holds >
		  (curship->holds -
		   (curship->ore + curship->organics + curship->equipment +
		    curship->colonists)))
		{
		  strcpy (buffer, "BAD: User does not have enough holds");
		  return;
		}
	    }
	  else
	    strcpy (buffer, "BAD: Port does not sell or buy");
	  deviation = .05 * mean;
	  offered = box_muller (mean, deviation);
	  if (playerprice == -1)	//In case we're getting a test price
	    {
	      fprintf (stderr, "Got a test price for %d\n", offered);
	      curplayer->lastprice = 0;
	      curplayer->firstprice = 0;
	    }
	  else
	    {
	      curplayer->lastprice = offered;
	      curplayer->firstprice = offered;
	    }
	  xpgained = 0;
	  accepted = 0;
	}
    }
  else if (curplayer->lastprice != 0)
    {
      if (product != 3)
	{
	  if (portconversion[curport->type][product] == 'B')
	    {
	      if ((playerprice <= (firstprice / 0.967 - 2)) ||
		  (playerprice <= curplayer->firstprice))
		{
		  accepted = 1;
		  xpgained = 0;
		}
	      else if ((playerprice >= (firstprice / 0.967 - 1)) &&
		       (playerprice <= (firstprice / 0.967 + 1)))
		{
		  accepted = 1;
		  xpgained = 5;
		}
	      else if ((playerprice >= (firstprice / 0.967 + 2)) &&
		       (playerprice <= (firstprice / 0.967 + 5)))
		{
		  accepted = 1;
		  xpgained = 2;
		}
	      else if (playerprice >= (1.1 * firstprice / 0.967))
		{
		  accepted = 0;
		  xpgained = 0;
		  offered = curplayer->lastprice;
		}
	      else if ((playerprice > (1.05 * firstprice / 0.967)) &&
		       (playerprice < (1.1 * firstprice / 0.967)))
		{
		  accepted = 0;
		  xpgained = 0;
		  offered = curplayer->lastprice + 1;
		}
	      else if (playerprice <= (1.05 * firstprice / 0.967))
		{
		  offered = (firstprice / 0.967 + lastprice) / 2;
		  accepted = 0;
		  xpgained = 0;
		}
	      if (playerprice >= 3 * firstprice)
		{
		  accepted = -1;
		  xpgained = 0;
		}
	      if ((offered >= playerprice) && offered != 0
		  && playerprice < 3 * firstprice)
		{
		  accepted = 1;
		  xpgained = 0;
		}
	      holds = 0 - holds;	//If buying from player want to decriment holds
	    }
	  else if (portconversion[curport->type][product] == 'S')
	    {
	      fprintf (stderr, "Offered price is %d, They have %d\n",
		       playerprice, curplayer->credits);
	      if (playerprice > curplayer->credits)	//In case someones trying to
		{		//out fox the system
		  buffer[0] = '\0';
		  addint (buffer, curplayer->lastprice, ':', BUFF_SIZE);
		  addint (buffer, accepted, ':', BUFF_SIZE);
		  addint (buffer, xpgained, ':', BUFF_SIZE);
		  return;
		}
	      if (holds >
		  (curship->holds -
		   (curship->ore + curship->organics + curship->equipment +
		    curship->colonists)))
		{
		  strcpy (buffer, "BAD: User does not have enough holds");
		  return;
		}
	      if ((playerprice >= (firstprice * 0.967 + 2)) ||
		  (playerprice >= curplayer->firstprice))
		{
		  accepted = 1;
		  xpgained = 0;
		}
	      else if ((playerprice <= (firstprice * 0.967 + 1)) &&
		       (playerprice >= (firstprice * 0.967 - 1)))
		{
		  accepted = 1;
		  xpgained = 5;
		}
	      else if ((playerprice <= (firstprice * 0.967 - 2)) &&
		       (playerprice >= (firstprice * 0.967 - 5)))
		{
		  accepted = 1;
		  xpgained = 2;
		}
	      else if (playerprice <= (.9 * firstprice * 0.967))
		{
		  accepted = 0;
		  xpgained = 0;
		  offered = curplayer->lastprice;
		}
	      else if ((playerprice > (.9 * firstprice * 0.967)) &&
		       (playerprice <= (.95 * firstprice * 0.967)))
		{
		  accepted = 0;
		  xpgained = 0;
		  offered = curplayer->lastprice - 1;
		}
	      else if (playerprice > (.95 * firstprice * 0.967))
		{
		  accepted = 0;
		  xpgained = 0;
		  offered = (lastprice + firstprice * 0.967) / 2;
		}
	      if ((offered <= playerprice) && offered != 0)
		{
		  accepted = 1;
		}
	      if (playerprice == 0)
		{
		  accepted = -1;
		}
	      playerprice = 0 - playerprice;	//Deduction from players credits
	    }
	}
    }
  if (accepted == 1)
    {
      fprintf (stderr, "Price accepted!\n");
      curplayer->lastprice = curplayer->firstprice = 0;
      curplayer->experience = curplayer->experience + xpgained;
      curplayer->credits = curplayer->credits + playerprice;
      switch (product)
	{
	case 0:
	  curship->ore = curship->ore + holds;
	  type = 4;
	  break;
	case 1:
	  curship->organics = curship->organics + holds;
	  type = 2;
	  break;
	case 2:
	  curship->equipment = curship->equipment + holds;
	  type = 1;
	  break;
	default:
	  break;
	}
      curport->product[product] = curport->product[product] - holds;
      curport->credits = curport->credits - playerprice;
      if (curport->credits < 0)
	curport->credits = 0;
      if (portconversion[curport->type][product] == 'B')
	{
	  if (curproduct / maxproduct >= .9)	//If past .9 full of buying
	    {
	      if ((curport->type != 0) || (curport->type != 9))
		{
		  if (curport->type == 8)
		    curport->type = 0 ^ type;
		  else
		    curport->type = curport->type ^ type;	//Switch to selling
		}
	    }

	}
      else if (portconversion[curport->type][product] == 'S')
	{
	  if (curproduct / maxproduct <= .1)	//If past %10 selling
	    {
	      if ((curport->type != 0) || (curport->type != 9))
		{
		  if (curport->type == 8)
		    curport->type = 0 ^ type;	//Switch to buying
		  else
		    curport->type = curport->type ^ type;
		}
	    }
	}
    }
  else if (playerprice != -1)
    curplayer->lastprice = offered;
  buffer[0] = '\0';
  if (accepted == -1)
    {
      curplayer->firstprice = 0;
      curplayer->lastprice = 0;
    }
  addint (buffer, offered, ':', BUFF_SIZE);
  addint (buffer, accepted, ':', BUFF_SIZE);
  addint (buffer, xpgained, ':', BUFF_SIZE);
}

/**************** WORKING *************************/
void
buildnewplanet (struct player *curplayer, char *buffer, int sector)
{
  int i, p_num = 0, p_sec, p_type;
  char *p_name, *p_owner;
  char p_ownertype = 'p', dummy;
  char *planetname = (char *) malloc (sizeof (char) * (MAX_NAME_LENGTH + 1));
  int input;

  p_name = (char *) malloc (sizeof (char) * (MAX_NAME_LENGTH + 1));
  popstring (buffer, planetname, ":", BUFF_SIZE);
  input = popint (buffer, ":");

  if (input != 1)
    {
      if (curplayer->lastplanet != 0)
	{
	  strcpy (buffer, "BAD: You have already created a planet!");
	  return;
	}
      else
	{
	  //This should really be a probability distribution with M being at the top
	  // followed by L, O, K, H, U, C. But for now this will work
	  p_type = randomnum (1, configdata->number_of_planet_types - 1);
	  curplayer->lastplanet = p_type;
	  strcpy (buffer, "\0");
	  addstring (buffer, planetTypes[p_type]->typeClass, ':', BUFF_SIZE);
	  addstring (buffer, planetTypes[p_type]->typeName, ':', BUFF_SIZE);
	  return;
	}
    }

  for (i = 0; i <= configdata->max_total_planets; i++)
    {
      if (planets[i] == NULL)
	{
	  p_num = i + 1;
	  break;
	}
    }

  p_type = curplayer->lastplanet;
  curplayer->lastplanet = 0;
  strcpy (buffer, "OK: Creating planet!");
  planets[p_num - 1] = (struct planet *) malloc (sizeof (struct planet));
  planets[p_num - 1]->num = p_num;
  planets[p_num - 1]->name =
    (char *) malloc ((MAX_NAME_LENGTH + 1) * sizeof (char));
  strcpy (planets[p_num - 1]->name, planetname);
  planets[p_num - 1]->owner = curplayer->number;
  planets[p_num - 1]->sector = sector;
  planets[p_num - 1]->creator =
    (char *) malloc (sizeof (char) * (MAX_NAME_LENGTH + 1));
  strcpy (planets[p_num - 1]->creator, curplayer->name);
  planets[p_num - 1]->type = p_type;
  planets[p_num - 1]->citdl =
    (struct citadel *) malloc (sizeof (struct citadel));
  planets[p_num - 1]->pClass = planetTypes[p_type];
  planets[p_num - 1]->fuelColonist = 0;
  planets[p_num - 1]->organicsColonist = 0;
  planets[p_num - 1]->equipmentColonist = 0;
  planets[p_num - 1]->fuel = 0;
  planets[p_num - 1]->organics = 0;
  planets[p_num - 1]->equipment = 0;
  planets[p_num - 1]->fighters = 0;
  planets[p_num - 1]->citdl->level = 0;
  planets[p_num - 1]->citdl->treasury = 0;
  planets[p_num - 1]->citdl->militaryReactionLevel = 0;
  planets[p_num - 1]->citdl->qCannonAtmosphere = 0;
  planets[p_num - 1]->citdl->qCannonSector = 0;
  planets[p_num - 1]->citdl->planetaryShields = 0;
  planets[p_num - 1]->citdl->transporterlvl = 0;
  planets[p_num - 1]->citdl->interdictor = 0;

  /* The above is wrong! The planet init reads the player number as a
   ** planet type. Need to modify the bigbang to to insert a planet type at
   ** in place of number, and then use the "dummy" value to be the owner number
   **
   ** Still for the moment it works and inserts a planet.
   */

  //curplayer->sector = sector; //For some reason this causes problems
  //Put int ships[curplayer->ship - 1]->location = sector;
  //ships[curplayer->ship - 1]->location = sector;
  insert_planet (planets[p_num - 1],
		 sectors[ships[curplayer->ship - 1]->location - 1],
		 curplayer->number);
}

/*****************************************/

void
buildnewplayer (struct player *curplayer, char *shipname)
{

  int i;			//A counter
  struct ship *curship;
  for (i = 0; i <= configdata->max_players; i++)
    {
      if (players[i] == NULL)
	break;
    }
  curplayer->number = i + 1;
  players[i] = curplayer;

  for (i = 0; i <= configdata->max_ships; i++)
    {
      if (ships[i] == NULL)
	break;
    }
  curplayer->experience = 0;
  curplayer->alignment = 0;
  curplayer->turns = configdata->turnsperday;
  curplayer->credits = configdata->startingcredits;
  curplayer->bank_balance = 0;
  curplayer->lastprice = 0;
  curplayer->firstprice = 0;
  curplayer->lastplanet = 0;
  //curplayer->ported = 0;
  curplayer->flags = P_LOGGEDIN;
  curplayer->loggedin = 1;
  if ((curship =
       (struct ship *) insert (shipname, ship, symbols, HASH_LENGTH)) == NULL)
    {
      fprintf (stderr, "buildnewplayer: duplicate shipname");
      // Just need to return BAD not bomb out completely!
      return (-1);
    }
  curship->number = i + 1;
  curship->name = (char *) malloc (strlen (shipname) + 1);
  strcpy (curship->name, shipname);
  curship->location = curplayer->sector;
  curship->type = 1;		//Start in a Merchant Cruiser
  curship->fighters = configdata->startingfighters;
  curship->shields = 0;
  curship->holds = configdata->startingholds;
  curship->colonists = 0;
  curship->equipment = 0;
  curship->organics = 0;
  curship->ore = 0;
  curship->owner = curplayer->number;
  curship->flags = 0;
  curship->onplanet = 0;
  curship->ported = 0;
  curplayer->ship = curship->number;
  curplayer->sector = 0;	//The player is now in a ship
  curplayer->messages = NULL;
  ships[i] = curship;
}


json_t *move_player(json_t *request_json)
{
    const char *player_name;
    int destination_sector;
    struct player *p;
    char buffer[1024];

    // 1. Validate the input JSON request
    json_t *name_json = json_object_get(request_json, "name");
    json_t *dest_json = json_object_get(request_json, "to");

    if (!json_is_string(name_json) || !json_is_integer(dest_json))
    {
        return json_pack("{s:s, s:i, s:s}",
                         "status", "error",
                         "error_code", 1180, // Invalid command
                         "message", "Invalid 'move' command format.");
    }

    player_name = json_string_value(name_json);
    destination_sector = json_integer_value(dest_json);

    // 2. Find the player based on the name from the JSON request
    p = (struct player *)find(player_name, player, symbols, HASH_LENGTH);
    if (p == NULL)
    {
        return json_pack("{s:s, s:i, s:s}",
                         "status", "error",
                         "error_code", 1230, // Unknown Player
                         "message", "Unknown Player.");
    }

    // 3. Check for movement errors (e.g., already moving, invalid destination)
    int current_sector = (p->sector == 0) ? ships[p->ship - 1]->location : p->sector;
    int link_found = 0;
    for (int i = 0; i < MAX_WARPS_PER_SECTOR; ++i)
    {
        if (sectors[current_sector - 1]->sectorptr[i] == NULL)
        {
            break;
        }
        if (sectors[current_sector - 1]->sectorptr[i]->number == destination_sector)
        {
            link_found = 1;
            break;
        }
    }

    if (!link_found)
    {
        return json_pack("{s:s, s:i, s:s}",
                         "status", "error",
                         "error_code", 1400, // Intransit Error
                         "message", "Invalid destination or no direct warp link exists.");
    }
    
    // 4. Check if the player has enough turns to move
    int turns_needed = shiptypes[ships[p->ship - 1]->type - 1]->turns;
    if (p->turns < turns_needed)
    {
        return json_pack("{s:s, s:i, s:s}",
                         "status", "error",
                         "error_code", 1110, // Insufficient Turns
                         "message", "Insufficient turns.");
    }

    // 5. All checks passed, perform the move
    
    // Remove player from the current sector's player list
    if (p->sector == 0)
    {
        delete(p->name, player, sectors[ships[p->ship - 1]->location - 1]->playerlist, 1);
        ships[p->ship - 1]->location = destination_sector;
    }
    else
    {
        delete(p->name, player, sectors[p->sector - 1]->playerlist, 1);
        p->sector = destination_sector;
    }

    // Deduct turns
    p->turns -= turns_needed;

    // Add player to the new sector's player list
    insertitem(p, player, sectors[destination_sector - 1]->playerlist, 1);

    // 6. Build the successful JSON response
    json_t *sector_info_json = builddescription_json(destination_sector, p->number);
    if (sector_info_json == NULL)
    {
        // Handle case where building description fails
        return json_pack("{s:s, s:i, s:s}",
                         "status", "error",
                         "error_code", 1100, // Undefined Error
                         "message", "Failed to build sector description.");
    }

    // Create the final response object
    json_t *response_json = json_object();
    json_object_set_new(response_json, "status", json_string("ok"));
    json_object_set_new(response_json, "type", json_string("move_result"));
    json_object_set_new(response_json, "data", sector_info_json);

    return response_json;
}


void
fedcommlink (int playernum, char *message)
{
  char buffer[BUFF_SIZE];
  struct player *curplayer;
  int loop = 1;

  fprintf (stderr, "\nfedcommlink: Player # %d, sending '%s'", playernum,
	   message);
  fflush (stderr);
  strcpy (buffer, players[playernum - 1]->name);
  strcat (buffer, ":0:");
  strcat (buffer, message);
  strcat (buffer, ":\0");
  while (players[loop - 1] != NULL)
    {
      curplayer = players[loop - 1];
      if (curplayer->loggedin && (curplayer->number != playernum))
	addmessage (curplayer, buffer);
      loop++;
    }
}

void
sendtoallonline (char *message)
{
  int loop = 1;
  struct player *curplayer;

  while (players[loop - 1] != NULL)
    {
      curplayer = players[loop - 1];
      if (curplayer->loggedin)
	addmessage (curplayer, message);
      loop++;
    }
}

void
addmessage (struct player *curplayer, char *message)
{
  struct realtimemessage *curmessage = NULL, *newmessage = NULL;

  curmessage = curplayer->messages;
  newmessage =
    (struct realtimemessage *) malloc (sizeof (struct realtimemessage));
  if (curmessage != NULL)
    {
      while (curmessage->nextmessage != NULL)
	curmessage = curmessage->nextmessage;
    }
  newmessage->message = (char *) malloc (BUFF_SIZE);
  newmessage->nextmessage = NULL;
  strcpy (newmessage->message, message);
  //fprintf(stderr, "\naddmessage: Adding message %s", message);
  if (curplayer->messages == NULL)
    {
      curplayer->messages = newmessage;
      //fprintf(stderr,"\naddmessage: Look '%s's basemessage is NULL", curplayer->name);
    }
  else
    curmessage->nextmessage = newmessage;

}

void
sendtosector (int sector, int playernum, int direction, int planetnum)
{
  struct list *element;
  char buffer[50];
  char temp[5];
  int p = 0;

  sprintf (temp, ":%d:", direction);
  //For direction 1 is <name> warps into, -1 is <name> warps out of
  element = sectors[sector - 1]->playerlist[0];
  strcpy (buffer, players[playernum - 1]->name);
  strcat (buffer, temp);
  if (direction == 5 || direction == -5)
    {
      strcat (buffer, planets[planetnum - 1]->name);
      strcat (buffer, ":");
    }
  if (element == NULL)
    {
      return;
    }
  else
    {
      do
	{
	  if (((struct player *) element->item)->number != playernum)
	    {
	      if ((p != 0) && (players[p - 1]->loggedin))
		addmessage (players[p - 1], buffer);
	      p = ((struct player *) element->item)->number;
	    }
	  element = element->listptr;
	}
      while (element != NULL);
      if ((p != 0) && (players[p - 1]->loggedin))
	addmessage (players[p - 1], buffer);
      else;
    }


}

int
innode (int sector)
{
  int counter;
  int nodemin;
  int nodemax;

  if (configdata->numnodes == 1)
    {
      return 1;
    }
  for (counter = 1; counter <= configdata->numnodes; counter++)
    {
      nodemin = nodes[counter - 1]->min;
      nodemax = nodes[counter - 1]->max;
      if (sector >= nodemin && sector <= nodemax)
	{
	  return (counter);
	}
    }
  return (-1);
}

void
listnodes (char *buffer, struct port *curport)
{
  int curnode;
  int counter;

  for (counter = 0; counter < configdata->numnodes; counter++)
    {
      if (nodes[counter]->portptr != curport)
	{
	  addstring (buffer, nodes[counter]->portptr->name, ',', BUFF_SIZE);
	  addint (buffer, nodes[counter]->number, ':', BUFF_SIZE);
	}
    }
}

void
nodetravel (char *buffer, struct player *curplayer)
{
  int nodeto = 0;

  gettimeofday (&begin, 0);
  nodeto = popint (buffer, ":");
  if (curplayer->turns < 10)
    {
      strcpy (buffer, "BAD: Not enough turns!");
      return;
    }
  if ((nodeto > configdata->numnodes) || (nodeto < 1))
    {
      strcpy (buffer, "BAD: Invalid Node!");
      return;
    }
  if (curplayer->sector == 0)
    {
      ships[curplayer->ship - 1]->location =
	nodes[nodeto - 1]->portptr->location;

    }
  else
    {
      curplayer->sector = nodes[nodeto - 1]->portptr->location;
    }
  curplayer->intransit = 1;
  curplayer->movingto = nodes[nodeto - 1]->portptr->location;
  curplayer->beginmove = begin.tv_sec;
  strcpy (buffer, "OK: Moving to a new node!");
  return;
}


json_t *
buildplayerinfo_json (struct player *curplayer)
{
  json_t *player_json = json_object ();
  json_object_set_new (player_json, "name", json_string (curplayer->name));
  json_object_set_new (player_json, "credits",
		       json_integer (curplayer->credits));
  json_object_set_new (player_json, "turns", json_integer (curplayer->turns));
  json_object_set_new (player_json, "fighters",
		       json_integer (curplayer->fighters));
  json_object_set_new (player_json, "holds", json_integer (curplayer->holds));
  json_object_set_new (player_json, "ship_number",
		       json_integer (curplayer->ship));
  return player_json;
}

json_t *
buildshipinfo_json (struct ship *curship)
{
  json_t *ship_json = json_object ();
  json_object_set_new (ship_json, "attack", json_integer (curship->attack));
  json_object_set_new (ship_json, "shields", json_integer (curship->shields));
  json_object_set_new (ship_json, "holds_used",
		       json_integer (curship->holds_used));
  json_object_set_new (ship_json, "fighters",
		       json_integer (curship->fighters));
  json_object_set_new (ship_json, "mines", json_integer (curship->mines));
  json_object_set_new (ship_json, "fighters_used",
		       json_integer (curship->fighters_used));
  json_object_set_new (ship_json, "genesis", json_integer (curship->genesis));
  json_object_set_new (ship_json, "photon_torps",
		       json_integer (curship->photons));
  return ship_json;
}

json_t *
buildportinfo_json (struct port *curport)
{
  json_t *port_json = json_object ();
  json_object_set_new (port_json, "port_size", json_integer (curport->size));
  json_object_set_new (port_json, "tech_level",
		       json_integer (curport->techlevel));
  return port_json;
}

json_t *
totalplanetinfo_json (struct planet *curplanet)
{
  json_t *planet_json = json_object ();
  json_object_set_new (planet_json, "population",
		       json_integer (curplanet->population));
  json_object_set_new (planet_json, "minerals",
		       json_integer (curplanet->minerals));
  json_object_set_new (planet_json, "organics",
		       json_integer (curplanet->organics));
  json_object_set_new (planet_json, "ore", json_integer (curplanet->ore));
  json_object_set_new (planet_json, "energy",
		       json_integer (curplanet->energy));

  if (curplanet->citdl != NULL)
    {
      json_t *citadel_json = json_object ();
      json_object_set_new (citadel_json, "owner", json_string (curplanet->citdl->owner));
      json_object_set_new (citadel_json, "military",  json_integer (curplanet->citdl->military));
      json_object_set_new (citadel_json, "qcannon",
			   json_integer (curplanet->citdl->qcannon));
      json_object_set_new (planet_json, "citadel", citadel_json);
    }
  return planet_json;
}
