# ADR-012 — SQL Dialect Cleanliness & Database Strategy

**Status:** Accepted
**Date:** 2026-01-05
**Decision Owner:** Engineering (Backend)

## Context

The `twclone` codebase contains a database abstraction layer intended to reduce coupling between application logic and database-specific SQL. In practice:

* PostgreSQL is the **only fully supported runtime database**.
* Other backends (MySQL, Oracle, SQLite) are incomplete or non-functional.
* PostgreSQL-specific SQL (e.g. `ON CONFLICT`, `::type`, `EXTRACT(EPOCH)`, `$N` placeholders) has leaked into application-level code (`src/`), increasing complexity, bugs, and refactor cost.

Recent work exposed concrete issues around timestamps, placeholders, and SQL portability, demonstrating that dialect leakage is already causing defects even when PostgreSQL is the only target.

## Decision

1. **PostgreSQL remains the only supported runtime database.**

   * No commitment is made to MySQL/Oracle support at this time.

2. **Application code must be dialect-clean.**

   * No PostgreSQL-specific SQL syntax is permitted outside the SQL abstraction layer.
   * All dialect variance must be isolated in `sql_driver.*` (or equivalent DB backend code).

3. **Dialect-clean ≠ multi-database support.**

   * Helper functions may return errors or NULL for unsupported backends.
   * This is acceptable and expected.

4. **Timestamps are DB-native and UTC.**

   * “Now” is generated by the database via `sql_now_expr(db)`.
   * Epoch conversion is performed via `sql_ts_to_epoch_expr(db, …)` when required.
   * No hardcoded `EXTRACT(EPOCH ...)`, `to_timestamp()`, or `time(NULL)` in SQL callsites.

5. **Portable placeholder syntax is mandatory.**

   * Application SQL uses `{N}` placeholders only.
   * Conversion to backend syntax happens exclusively via `sql_build()`.

## Consequences

**Positive**

* Eliminates SQL dialect bugs and confusion.
* Simplifies refactoring and future backend work.
* Prevents PostgreSQL syntax from spreading further.
* Improves code clarity and testability.

**Negative**

* Some PostgreSQL-only features remain unimplemented for other backends.
* Additional helper functions are required in the abstraction layer.

## Non-Goals

* Implementing MySQL or Oracle drivers.
* Guaranteeing cross-database feature parity.
* Removing PostgreSQL-specific logic from the backend layer.

---

# PR Checklist — Dialect-Clean Enforcement

**This checklist is mandatory for any PR touching SQL.**

## Scope & Safety

* [ ] Only approved files modified (per PR scope).
* [ ] No schema changes unless explicitly approved.
* [ ] No refactors beyond mechanical dialect cleanup.

## SQL Rules

* [ ] No `$1`, `$2`, … placeholders remain in modified files.
* [ ] All SQL uses `{N}` placeholders.
* [ ] All executed SQL passes through `sql_build()`.

## Forbidden in `src/`

* [ ] No `::type` casts.
* [ ] No `ON CONFLICT`, `FOR UPDATE SKIP LOCKED`, `EXTRACT(EPOCH`, `NOW()`, `to_timestamp()` literals.
* [ ] No PostgreSQL JSON functions (`json_*`) outside abstraction helpers.

## Required Helpers

* [ ] Timestamp “now” uses `sql_now_expr(db)`.
* [ ] Timestamp → epoch conversion uses `sql_ts_to_epoch_expr(db, ...)`.
* [ ] Backend-specific behaviour is delegated to `sql_driver.*`.

## Verification (must paste output)

```sh
rg '\$[0-9]+' <TARGET_FILE> || true
rg '::[a-zA-Z]' <TARGET_FILE> || true
rg 'EXTRACT\(EPOCH|ON CONFLICT|FOR UPDATE|to_timestamp|NOW\(' <TARGET_FILE> || true
make clean && make -j
git diff --name-only
```

Expected:

* No matches for forbidden patterns.
* Build succeeds.
* Only intended files modified.

---

# CI Guardrail — Prevent Dialect Leakage

Add this as a CI step (or pre-commit hook).

## Script: `tools/ci_sql_dialect_guard.sh`

```sh
#!/bin/sh
set -e

echo "Checking for forbidden PostgreSQL syntax in src/ ..."

fail() {
  echo "ERROR: PostgreSQL-specific SQL detected:"
  echo "$1"
  exit 1
}

rg '\$[0-9]+' src/ && fail "\$N placeholders found"
rg '::[a-zA-Z]' src/ && fail "PostgreSQL ::type casts found"
rg 'ON CONFLICT' src/ && fail "ON CONFLICT found outside abstraction"
rg 'FOR UPDATE SKIP LOCKED' src/ && fail "FOR UPDATE SKIP LOCKED found outside abstraction"
rg 'EXTRACT\(EPOCH' src/ && fail "EXTRACT(EPOCH) found outside abstraction"
rg 'to_timestamp\(' src/ && fail "to_timestamp() found outside abstraction"
rg '\bNOW\(\)' src/ && fail "NOW() found outside abstraction"

echo "SQL dialect guard passed."
```

## CI Usage

```sh
chmod +x tools/ci_sql_dialect_guard.sh
tools/ci_sql_dialect_guard.sh
```

This guarantees:

* PostgreSQL syntax **cannot leak back into `src/`**
* All dialect-specific SQL stays contained
* Future refactors don’t reintroduce this class of bugs

